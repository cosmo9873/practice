{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier-Oblique;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red255\green246\blue214;
\red41\green67\blue135;\red143\green144\blue150;\red249\green249\blue249;\red42\green44\blue51;\red66\green147\blue62;
\red133\green85\blue4;\red147\green0\blue147;}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c100000\c96863\c87059;
\cssrgb\c21176\c34510\c60000;\cssrgb\c62745\c63137\c65490;\cssrgb\c98039\c98039\c98039;\cssrgb\c21961\c22745\c25882;\cssrgb\c31373\c63137\c30980;
\cssrgb\c59608\c40784\c392;\cssrgb\c65098\c14902\c64314;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Base64 Encoder\
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb1 \pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb4 \'a0
\f0\b Warning!
\f1\b0 \'a0This is a new question. It may or may not provide good signal. Please reach out to swhitaker@ if you use this question so I can get your feedback on it. Thanks!\
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Author:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=687406370"}}{\fldrslt \cf5 \strokec5 Simon Whitaker}}\cb1 \
\cb3 Difficulty: Not yet calibrated\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Tell me what base 64 encoding does. What's its purpose?\cb1 \
\cb3 OK, now write a base 64 encoder. Given some bytes as input, output the base-64 encoded string for those bytes.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Basic code solution\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\i\b0\fs30 \cf2 \cb3 Aside: Is there a word for an n-bit chunk of data? e.g. 8 bits is a byte, 4 bits is a nibble \'96 but what's 6 bits called? 5 bits? I've called it a "morsel" here, but that's just the word I decided on.
\i0 \cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\i \cf6 \cb7 \strokec6 #!/usr/bin/env python
\f3\i0 \cf8 \strokec8 \
\
B64_CHARS = \cf9 \strokec9 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\cf8 \strokec8 \
\
data = bytearray(range(\cf10 \strokec10 100\cf8 \strokec8 ))\
\
index = \cf10 \strokec10 0\cf8 \strokec8 \
bit_index = \cf10 \strokec10 0\cf8 \strokec8 \
output = \cf9 \strokec9 ''\cf8 \strokec8 \
\
\pard\pardeftab720\sl480\partightenfactor0
\cf11 \strokec11 while\cf8 \strokec8  index < len(data):\
    morsel = ((data[index] << bit_index) & \cf10 \strokec10 255\cf8 \strokec8 ) >> \cf10 \strokec10 2\cf8 \strokec8 \
    \cf11 \strokec11 if\cf8 \strokec8  index < len(data) - \cf10 \strokec10 1\cf8 \strokec8 :\
        morsel += data[index + \cf10 \strokec10 1\cf8 \strokec8 ] >> (\cf10 \strokec10 10\cf8 \strokec8  - bit_index)\
\
    bit_index += \cf10 \strokec10 6\cf8 \strokec8 \
    \cf11 \strokec11 if\cf8 \strokec8  bit_index >= \cf10 \strokec10 8\cf8 \strokec8 :\
        bit_index = bit_index % \cf10 \strokec10 8\cf8 \strokec8 \
        index += \cf10 \strokec10 1\cf8 \strokec8 \
\
    output += B64_CHARS[morsel]\
\
\cf11 \strokec11 while\cf8 \strokec8  len(output) % \cf10 \strokec10 4\cf8 \strokec8  > \cf10 \strokec10 0\cf8 \strokec8 :\
    output += \cf9 \strokec9 '='\cf8 \strokec8 \
\
\cf11 \strokec11 print\cf8 \strokec8  output\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 \strokec2 Follow on\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Some ideas you might try:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write the matching decoder\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Generalise the code so that it can also do e.g. base32 encoding\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Finding the signal\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 Knowledge\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Knows what base 64-encoding is\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Knows that there are various base-64 standards\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Knows the character set used in a common base-64 encoding standard (commonly A-Z, a-z, 0-9, + and /)\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Knows that base-64 text is commonly padded with equals signs (=) such that its length is divisible by 4.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Knows how to manipulate binary data bitwise in their language of choice\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Coding\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Intuitive, self-descriptive variable names\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Clear distinction between character and bit indices\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Correct use of bitwise operators\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 No out-by-one errors (this question is littered with them!)\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Clean separation of concerns: a solution that can handle multiple bases of output should cleanly separate the code for bit shifting and generating a sequence of integers for the input data from the code for encoding those integers as ASCII characters, concatenating them, adding trailing = characters, etc.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Problem solving\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls4\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Generalises the solution so that it takes the morsel length as an argument, and can be repurposed to do base32- and base16 encoding\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Alternative solutions\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 With configurable output base\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 The configurable "morsel size" here makes this reusable for base64, base32, base16, etc.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\i \cf6 \cb7 \strokec6 #!/usr/bin/env python
\f3\i0 \cf8 \strokec8 \
\
B64_CHARS = \cf9 \strokec9 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\cf8 \strokec8 \
\
def get_morsels(bytes, morsel_size):\
    index = \cf10 \strokec10 0\cf8 \strokec8 \
    bit_index = \cf10 \strokec10 0\cf8 \strokec8 \
    \cf11 \strokec11 while\cf8 \strokec8  index < len(bytes):\
        morsel = ((bytes[index] << bit_index) & \cf10 \strokec10 255\cf8 \strokec8 ) >> (\cf10 \strokec10 8\cf8 \strokec8  - morsel_size)\
        \cf11 \strokec11 if\cf8 \strokec8  index < len(bytes) - \cf10 \strokec10 1\cf8 \strokec8 :\
            morsel += bytes[index + \cf10 \strokec10 1\cf8 \strokec8 ] >> ((\cf10 \strokec10 16\cf8 \strokec8  - morsel_size) - bit_index)\
\
        
\f2\i \cf6 \strokec6 # Advance the bit index
\f3\i0 \cf8 \strokec8 \
        bit_index += morsel_size\
        \cf11 \strokec11 if\cf8 \strokec8  bit_index >= \cf10 \strokec10 8\cf8 \strokec8 :\
            bit_index = bit_index % \cf10 \strokec10 8\cf8 \strokec8 \
            index += \cf10 \strokec10 1\cf8 \strokec8 \
\
        
\f2\i \cf6 \strokec6 # for now, let's assume b32 uses the first 32 chars of B64_CHARS,
\f3\i0 \cf8 \strokec8 \
        
\f2\i \cf6 \strokec6 # b16 uses the first 16, etc. Can easily add separate character sets
\f3\i0 \cf8 \strokec8 \
        
\f2\i \cf6 \strokec6 # later if required.
\f3\i0 \cf8 \strokec8 \
        \cf11 \strokec11 yield\cf8 \strokec8  B64_CHARS[morsel]\
\
def main():\
    \cf11 \strokec11 for\cf8 \strokec8  morsel_size in range(\cf10 \strokec10 3\cf8 \strokec8 , \cf10 \strokec10 7\cf8 \strokec8 ):\
        \cf11 \strokec11 for\cf8 \strokec8  input_size in range(\cf10 \strokec10 1\cf8 \strokec8 , \cf10 \strokec10 100\cf8 \strokec8 , \cf10 \strokec10 7\cf8 \strokec8 ):\
            data = bytearray(range(input_size))\
            morsels = \cf9 \strokec9 ''\cf8 \strokec8 .join(get_morsels(data, morsel_size))\
            num_bits = len(data) * \cf10 \strokec10 8\cf8 \strokec8 \
            expected_output_length = num_bits / morsel_size\
            \cf11 \strokec11 if\cf8 \strokec8  num_bits % morsel_size:\
                expected_output_length += \cf10 \strokec10 1\cf8 \strokec8 \
            \cf11 \strokec11 print\cf8 \strokec8 (\cf9 \strokec9 "For morsel size %i and input size %i, "\cf8 \strokec8 \
                  \cf9 \strokec9 "expected output size %i, got %i"\cf8 \strokec8  % (\
                morsel_size,\
                input_size,\
                expected_output_length,\
                len(morsels)\
            ))\
            assert(len(morsels) == expected_output_length)\
\
\pard\pardeftab720\sl480\partightenfactor0
\cf11 \strokec11 if\cf8 \strokec8  __name__ == \cf9 \strokec9 '__main__'\cf8 \strokec8 :\
    main()\
}