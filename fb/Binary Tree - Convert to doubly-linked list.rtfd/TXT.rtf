{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red41\green67\blue135;
\red42\green44\blue51;\red249\green249\blue249;\red133\green85\blue4;\red242\green245\blue249;\red0\green0\blue0;
\red147\green0\blue147;\red50\green94\blue238;\red14\green112\blue173;\red178\green113\blue6;\red143\green144\blue150;
\red66\green147\blue62;}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c21176\c34510\c60000;
\cssrgb\c21961\c22745\c25882;\cssrgb\c98039\c98039\c98039;\cssrgb\c59608\c40784\c392;\cssrgb\c96078\c96863\c98039;\cssrgb\c0\c0\c0;
\cssrgb\c65098\c14902\c64314;\cssrgb\c25098\c47059\c94902;\cssrgb\c392\c51765\c73333;\cssrgb\c75686\c51765\c392;\cssrgb\c62745\c63137\c65490;
\cssrgb\c31373\c63137\c30980;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid801\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid901\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1001\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid15}
{\list\listtemplateid16\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid16}
{\list\listtemplateid17\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid17}
{\list\listtemplateid18\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid18}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}{\listoverride\listid16\listoverridecount0\ls16}{\listoverride\listid17\listoverridecount0\ls17}{\listoverride\listid18\listoverridecount0\ls18}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Tree to List\
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 Owner:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=1057890118"}}{\fldrslt \cf4 \strokec4 Wendy Mu}}\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0
\f0\b \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Ninja Brown Bag Recordings:
\f1\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/vod/view/546477145529545/%20"}}{\fldrslt \cf4 \strokec4 12/7/2015}}\'a0I\'a0{\field{\*\fldinst{HYPERLINK "https://www.facebook.com/internalvideos/videos/801729063371473/"}}{\fldrslt \cf4 \strokec4 4/19/16}}\cb1 \
\ls1\ilvl0
\f0\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 PowerPoint:
\f1\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.dropbox.com%2Fs%2Fhlx3fn9bhc8o00b%2FNinja%2520BB%2520Tree%2520to%2520List.pptx%3Fdl%3D0&h=AT0qgIhisbd0s6QRXreaPSyNXvchLSprkuJTriMtYCzdAgI5sE1o86iUtohS8TUNEKHWnwQAMJ3otJ_GAlZeZGZ4yFf3Oi0DTt3VrRbwTizHZxh8NqKU3bBR8pS729325LL4tLgBHvAlPcnxO7cEM9BG"}}{\fldrslt \cf4 \strokec4 https://www.dropbox.com/s/hlx3fn9bhc8o00b/Ninja%20BB%20Tree%20to%20List.pptx?dl=0}}\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Background\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Difficulty: Medium\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Time expectation: 25 minutes\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 This question is a good test of fluency with pointers, recursion, and basic data structures. I've seen it on the Internet a few times, so perhaps beware when using it in phone screens. And since the thought process for doing this should involve a lot of diagrams, it's probably better done in person.\cb1 \
\cb3 This is the most difficult coding question I can remember seeing that involves only the very basic data structures of binary tree and linked list.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Problem statement\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Here is a struct definition for a node that works for\'a0
\f0\b both
\f1\b0 \'a0binary trees and doubly-linked lists:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf5 \cb6 \strokec5 struct Node \{\
  struct Node* left;\
  struct Node* right;\
  int data;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Given a binary tree made of these nodes, convert it, in-place (i.e. don't allocate new Nodes), into a circular doubly linked list in the same order as an in-order traversal of the tree. That is, a traversal of the linked list and an in-order traversal of the tree should yield the elements in the same order. You should return the head of the linked list.\cb1 \
\cb3 Note: It's important to make it clear that we're updating the existing tree's left/right pointers. Oftentimes candidates start coding and expect they're going to return a new linked list.\cb1 \
\cb3 I always draw an example on the board with a few nodes. I usually include at least one grandchild that lies in the middle like the following:\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf5 \cb6 \strokec5 Input\
 -> \cf7 \strokec7 3\cf5 \strokec5 \
   / \
  \cf7 \strokec7 1\cf5 \strokec5  \
   \\\
    \cf7 \strokec7 2\cf5 \strokec5 \
\
Output\
-> \cf7 \strokec7 1\cf5 \strokec5  <-> \cf7 \strokec7 2\cf5 \strokec5  <-> \cf7 \strokec7 3\cf5 \strokec5 \
   ^           ^\
   |___________|\
    (circular)\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb1 \strokec2 \pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb8 \'a0
\f0\b Notice!
\f1\b0 \'a0A common solution is to traverse the tree and put all the nodes into a queue. If the candidate proposes this solution, I acknowledge that it works but ask for a solution that involves less than O(size of tree) space. Alternatively, you can to add a constraint to only go through all the nodes once.\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Solutions\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 One nicety of this question is that there are many ways to skin the cat. Here are some common solutions:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1. Divide and conquer: recursively create a doubly linked lists and merge them. If the lists aren't circular, it should return both the head and tail to avoid walking the result lists again.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 2. In-Order traversal maintaining a "previous" pointer. Simply perform an in-order traversal where the "last-visited node" is maintained and to which we point the current node's left pointer. This can be done recursively or iteratively.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 3. Top-down: pass down "boundaries" to the subtrees which create sublists with the constraints and change the boundaries' (if-non-null) pointers.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 These are all O(size of tree) time and O(depth of tree) space.\cb1 \
\cb3 Solution 1 is the most common solution. Solution 2 is also fairly common, but the iterative implementation can be a little tricky. I've never personally seen Solution 3, so it's probably a rare solution.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Hiring Evaluation\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 No hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls4\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 No working solution\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Needs a lot of hinting to figure out the algorithm, has trouble with "recursive leap of faith"\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Doesn\'92t appear to understand the algorithm\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Code doesn\'92t match algorithm described\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Breaks problem into a bunch of special cases (e.g., if (root->left) \{ if (root->left->left) ... \}); messy code\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Has trouble running through a test case\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Maybe hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls5\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Needs some hints to get to an algorithm (e.g., if you suggest thinking about the problem recursively, or how to keep track of the last node in the recursive lists returned, etc.)\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Code is mostly clean and correct\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Maybe a few bugs they could fix if there were more time (e.g., != instead of ==, mixing up ->left and ->right)\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls6\ilvl0\cf9 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec9 Can fix bugs if you help point them out\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls7\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Slower to get through the problem\cb1 \
\ls7\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can analyze time / space complexity\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls8\ilvl0\cf9 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec9 Can optimize if you ask them about it (e.g., if they are going through the entire list to get the last node, can figure out how to return it or access it in O(1) instead, or if they are using O(size of tree) memory)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Most likely hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls9\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 May need a few hints to get to algorithm (see sample hints above)\cb1 \
\ls9\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can translate their thoughts into code\cb1 \
\ls9\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Good understanding of recursion and the code they wrote\cb1 \
\ls9\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can find and fix bugs, maybe with some hints\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls10\ilvl0\cf9 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec9 Can come up with good test cases for their own code (e.g. if either the left or right side is null, etc.)\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls11\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Working solution at end\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Clean implementation\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Good understanding of time / space complexity\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Strong hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls12\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Quickly identifies algorithm on their own (either recursive or iterative)\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Maybe thinks of multiple algorithms; can articulate tradeoffs\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Clean implementation (e.g., with recursive, doesn't rewrite the same code to join lists 2-3 times but rather sees that it can be extracted into a helper)\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Clearly understands solution and can walk through examples\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can find their own bugs without hints (see sample test cases above)\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can talk about time / space complexity\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Process / Notes\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls13\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Ask candidate to talk through algorithm before writing code\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidates usually realize recursion works well\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Some weaker candidates try and solve the problem recursively, but only return the non-circular head of the list. This means they must walk the list to get to the left-subtree's rightmost node. I ask candidates to think of how they can get around this. An inability to come up with a solution to this on their own is usually enough signal for a no-hire.\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If they propose a solution that uses O(size of tree) memory, I usually ask if they can optimize further\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Very weak candidates can't get to any solution at all. Here I make the problem easier and ask them to code up an in-order traversal. From here I try and lead them towards the in-order solution.\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Get the candidate to test their solution by stepping through the code with accompanying diagrams. Watch to see if they come up with the empty-tree edge case on their own. Other cases they should think of include a complete tree and pathological left- and right-leaning trees.\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can ask follow-ups or another question, depending on time left\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Follow-ups\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls14\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Time / space complexity\cb1 \
\ls14\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Test cases\cb1 \
\ls14\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Some rockstar candidates dive into a working solution with maybe 1 or 2 bugs that they fix, and there's time left for a followup. A natural followup I often ask is: Convert the DLL we just made into an optimal (as "shallow" as possible) BST withoutout using a self-balancing tree/algorithm ({\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/wiki/Engineering/Interviewing/Ninja/ListToTree/"}}{\fldrslt \cf4 \strokec4 See here}}).\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Signal\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 First, see the page on\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/wiki/Engineering/Interviewing/Ninja/Ninja_Interview_Generic_Signals/"}}{\fldrslt \cf4 \strokec4 Generic Ninja Interview Signals}}\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Common Negative Signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls15\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Not understanding data structures or in-order traversal after having it explained\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Forgetting base case\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Overcomplicated base case (e.g., using 2 nodes as base case)\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Not able to structure recursion\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Not factoring out similar logic / writing the same logic multiple times\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Unable to optimize solution if using more than O(depth of tree) memory\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Glossing over bugs in code when walking through example\cb1 \
\ls15\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Wrong time / complexity analysis\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Common Positive Signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls16\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can clearly describe and implement algorithm\cb1 \
\ls16\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can optimize time / space complexity\cb1 \
\ls16\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Understands recursion\cb1 \
\ls16\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Factors out common code\cb1 \
\ls16\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Thinks of edge cases on their own\cb1 \
\ls16\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can find their own bugs\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Non-signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls17\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Which solution they pick\cb1 \
\ls17\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If they knew what an in-order traversal was beforehand\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Sample Solutions\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 These are the most common ones I've seen; a few more solutions / variants are at the end of the wiki.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Recursively construct lists & merge\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf10 \cb6 \strokec10 void\cf5 \strokec5  \cf11 \strokec11 joinNodes\cf5 \strokec5 (Node* front, Node* back) \{\
  front->right = back;\
  back->left = front;\
\}\
\
Node* \cf11 \strokec11 mergeLists\cf5 \strokec5 (Node* front, Node* back) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (front == \cf12 \strokec12 nullptr\cf5 \strokec5 ) \cf10 \strokec10 return\cf5 \strokec5  back;\
  \cf10 \strokec10 if\cf5 \strokec5  (back == \cf12 \strokec12 nullptr\cf5 \strokec5 ) \cf10 \strokec10 return\cf5 \strokec5  front;\
  Node* frontLast = front->left;\
  Node* backLast = back->left;\
  joinNodes(frontLast, back);\
  joinNodes(backLast, front);\
  \cf10 \strokec10 return\cf5 \strokec5  front;\
\}\
\
Node* \cf11 \strokec11 treeToList\cf5 \strokec5 (Node* root) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (root == \cf12 \strokec12 nullptr\cf5 \strokec5 ) \cf10 \strokec10 return\cf5 \strokec5  root;\
  Node* ll = treeToList(root->left);\
  Node* lr = treeToList(root->right);\
  root->left = root->right = root;\
  \cf10 \strokec10 return\cf5 \strokec5  mergeLists(mergeLists(ll, root), lr);\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 In-order traversal maintaining a previous pointer (recursive)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs30 \cf2 \cb3 \strokec2 RECURSIVE\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \strokec2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 bstToDLL\cf5 \strokec5 (root) \{\
  \cf10 \strokec10 var\cf5 \strokec5  prev = \cf12 \strokec12 null\cf5 \strokec5 ;\
  \cf10 \strokec10 var\cf5 \strokec5  solverHelper = \cf10 \strokec10 function\cf5 \strokec5  (node) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (!node) \{\
      \cf10 \strokec10 return\cf5 \strokec5  \cf12 \strokec12 null\cf5 \strokec5 ;\
    \}\
    \cf10 \strokec10 var\cf5 \strokec5  leftmost = solverHelper(node.left) || node;\
    node.left = prev;\
    \cf10 \strokec10 if\cf5 \strokec5  (prev) \{\
      prev.right = node;\
    \}\
    prev = node;\
    solverHelper(node.right);\
    \cf10 \strokec10 return\cf5 \strokec5  leftmost;\
  \};\
  \cf10 \strokec10 return\cf5 \strokec5  solverHelper(root);\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 ITERATIVE\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \strokec2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 void\cf5 \strokec5  \cf11 \strokec11 pushNodeAndLefts\cf5 \strokec5 (Node* node, \cf13 \strokec13 stack\cf5 \strokec5 <Node*> &\cf13 \strokec13 stack\cf5 \strokec5 ) \{\
  \cf10 \strokec10 while\cf5 \strokec5  (node != \cf12 \strokec12 nullptr\cf5 \strokec5 ) \{\
    \cf13 \strokec13 stack\cf5 \strokec5 .push(node);\
    node = node->left;\
  \}\
\}\
\
Node* \cf11 \strokec11 treeToListStack\cf5 \strokec5 (Node* root) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (root == \cf12 \strokec12 nullptr\cf5 \strokec5 ) \cf10 \strokec10 return\cf5 \strokec5  root;\
  \cf13 \strokec13 stack\cf5 \strokec5 <Node*> \cf13 \strokec13 stack\cf5 \strokec5 ;\
  pushNodeAndLefts(root, \cf13 \strokec13 stack\cf5 \strokec5 );\
  Node* head = \cf12 \strokec12 nullptr\cf5 \strokec5 ; Node* prev = \cf12 \strokec12 nullptr\cf5 \strokec5 ;\
  \cf10 \strokec10 while\cf5 \strokec5  (!\cf13 \strokec13 stack\cf5 \strokec5 .empty()) \{\
    Node* cur = \cf13 \strokec13 stack\cf5 \strokec5 .top(); \cf13 \strokec13 stack\cf5 \strokec5 .pop();\
    \cf10 \strokec10 if\cf5 \strokec5  (head == \cf12 \strokec12 nullptr\cf5 \strokec5 ) head = cur;\
    \cf10 \strokec10 if\cf5 \strokec5  (prev != \cf12 \strokec12 nullptr\cf5 \strokec5 ) \{\
      prev->right = cur;\
      cur->left = prev;\
    \}\
    pushNodeAndLefts(cur->right, \cf13 \strokec13 stack\cf5 \strokec5 );\
    prev = cur;\
  \}\
  prev->right = head;\
  head->left = prev;\
  \cf10 \strokec10 return\cf5 \strokec5  head;\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Top-down / Bounds (JS)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 bstToDLL\cf5 \strokec5 (root) \{\
  \cf10 \strokec10 var\cf5 \strokec5  solverHelper = \cf10 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 solverHelper\cf5 \strokec5 (node, lBounds, rBounds) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (!node) \{\
      \cf10 \strokec10 return\cf5 \strokec5  \cf12 \strokec12 null\cf5 \strokec5 ;\
    \}\
\
    
\f3\i \cf14 \strokec14 // Left subtree
\f2\i0 \cf5 \strokec5 \
    \cf10 \strokec10 var\cf5 \strokec5  leftmost = lBounds;\
    \cf10 \strokec10 if\cf5 \strokec5  (!node.left) \{\
      node.left = lBounds;\
      \cf10 \strokec10 if\cf5 \strokec5  (lBounds) \{\
        lBounds.right = node;\
      \}\
    \} \cf10 \strokec10 else\cf5 \strokec5  \{\
      leftmost = solverHelper(node.left, lBounds, node);\
    \}\
\
    
\f3\i \cf14 \strokec14 // Right subtree
\f2\i0 \cf5 \strokec5 \
    \cf10 \strokec10 if\cf5 \strokec5  (!node.right) \{\
      node.right = rBounds;\
      \cf10 \strokec10 if\cf5 \strokec5  (rBounds) \{\
        rBounds.left = node;\
      \}\
    \} \cf10 \strokec10 else\cf5 \strokec5  \{\
      solverHelper(node.right, node, rBounds);\
    \}\
    \cf10 \strokec10 return\cf5 \strokec5  leftmost || node;\
  \}\
  \cf10 \strokec10 return\cf5 \strokec5  solverHelper(root, \cf12 \strokec12 null\cf5 \strokec5 , \cf12 \strokec12 null\cf5 \strokec5 );\
\}\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 \strokec2 Things to watch for\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 As with any recursion-based question, a big clue right off the bat is whether they get the base case right. The operation being performed here is complicated enough that you just can't get away with having a more complex base case than "root == NULL". Taking the "recursive leap of faith" could be a big sticking point for candidates. "Trust that the recursive call works" is a good hint if they get irrevocably stuck or start tying themselves in knots by worrying about what's happening at the next level of recursion.\cb1 \
\cb3 A key realization is that the fact that the lists are circular and doubly-linked makes it easy to find their tails, which is important when concatenating them. Candidates have to resist the urge to somehow pass additional information back from each call.\cb1 \
\cb3 Diagrams are almost required when figuring out this problem. Candidates should be using diagrams to construct the code to concatenate circular doubly-linked lists together. If they're struggling and not drawing diagrams, definitely suggest that they do.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Appendix: Other solutions\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 Recursive Lists (JS)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 join\cf5 \strokec5 (end,front) \{\
  end.right = front;\
  front.left = end;\
\}\
\
\cf10 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 merge\cf5 \strokec5 (front, end) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (!front) \
    \cf10 \strokec10 return\cf5 \strokec5  end;\
  \cf10 \strokec10 if\cf5 \strokec5  (!end)\
    \cf10 \strokec10 return\cf5 \strokec5  front;\
  \cf10 \strokec10 var\cf5 \strokec5  frontLast = front.left;\
  \cf10 \strokec10 var\cf5 \strokec5  endLast = end.left;\
  join(frontLast, end); 
\f3\i \cf14 \strokec14 // join middle
\f2\i0 \cf5 \strokec5 \
  join(endLast, front); 
\f3\i \cf14 \strokec14 // make it circular
\f2\i0 \cf5 \strokec5 \
  \cf10 \strokec10 return\cf5 \strokec5  front;\
\}\
\
\pard\pardeftab720\sl480\partightenfactor0

\f3\i \cf14 \strokec14 // Makes a circular linked-list
\f2\i0 \cf5 \strokec5 \
\pard\pardeftab720\sl480\partightenfactor0
\cf10 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 bstToDLL\cf5 \strokec5 (node) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (!node) \{\
    \cf10 \strokec10 return\cf5 \strokec5  \cf12 \strokec12 null\cf5 \strokec5 ;\
  \}\
  \cf10 \strokec10 var\cf5 \strokec5  ll = bstToDLL(node.left);\
  \cf10 \strokec10 var\cf5 \strokec5  lr = bstToDLL(node.right);\
  node.left = node.right = node;\
  \cf10 \strokec10 return\cf5 \strokec5  merge(merge(ll, node), lr);\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 A kind of hybrid In-order boundary-type solution\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 courtesy of\'a0{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/profile/?id=1321639144"}}{\fldrslt \cf4 \strokec4 asukhachev}}\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 bstToDLL\cf5 \strokec5 (root) \{\
  \cf10 \strokec10 var\cf5 \strokec5  head = \cf12 \strokec12 null\cf5 \strokec5 ;\
  \cf10 \strokec10 var\cf5 \strokec5  visit = \cf10 \strokec10 function\cf5 \strokec5 (cur, prev) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (cur.left) \{\
      last = visit(cur.left, prev);\
      last.right = cur;\
      cur.left = last;\
    \} \cf10 \strokec10 else\cf5 \strokec5  \{\
      cur.left = prev;\
      \cf10 \strokec10 if\cf5 \strokec5  (prev) \{\
        prev.right = cur;\
      \}\
    \}\
    \cf10 \strokec10 if\cf5 \strokec5  (!head) \{\
      head = cur;\
    \}\
    \cf10 \strokec10 if\cf5 \strokec5  (cur.right) \{\
      \cf10 \strokec10 return\cf5 \strokec5  visit(cur.right, cur);\
    \}\
    \cf10 \strokec10 return\cf5 \strokec5  cur;\
  \};\
\
  \cf10 \strokec10 var\cf5 \strokec5  tail = visit(root, \cf12 \strokec12 null\cf5 \strokec5 );\
  tail.right = head;\
  head.left = tail;\
  \cf10 \strokec10 return\cf5 \strokec5  head;\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 right-then-left recursive solution in C\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Basically the premise is that if you construct the right subtree linked list, you can point root toward it and then pass root as the continuation for the left subtree. Then you just add the backpointers in one go. I have no idea if you're likely to see it in the wild or not.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3\i \cf14 \cb6 \strokec14 /* turn root into a linked list suffixed by rest */
\f2\i0 \cf5 \strokec5 \
\pard\pardeftab720\sl480\partightenfactor0
\cf10 \strokec10 static\cf5 \strokec5  \cf10 \strokec10 struct\cf5 \strokec5  Node *\cf11 \strokec11 to_ll\cf5 \strokec5 (\cf10 \strokec10 struct\cf5 \strokec5  Node *root, \cf10 \strokec10 struct\cf5 \strokec5  Node *rest) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (!root) \cf10 \strokec10 return\cf5 \strokec5  rest;\
    root->right = to_ll(root->right, rest);\
    \cf10 \strokec10 return\cf5 \strokec5  to_ll(root->left, root);\
\}\
\
\cf10 \strokec10 struct\cf5 \strokec5  Node *\cf11 \strokec11 make_circular\cf5 \strokec5 (\cf10 \strokec10 struct\cf5 \strokec5  Node *head) \{\
    \cf10 \strokec10 struct\cf5 \strokec5  Node *t;\
    \cf10 \strokec10 if\cf5 \strokec5  (!head) \cf10 \strokec10 return\cf5 \strokec5  \cf12 \strokec12 NULL\cf5 \strokec5 ;\
\
    \cf10 \strokec10 for\cf5 \strokec5  (t = head; t->right; t = t->right)\
        t->right->left = t;\
\
    t->right = head;\
    head->left = t;\
\
    \cf10 \strokec10 return\cf5 \strokec5  head;\
\}\
\
\cf10 \strokec10 struct\cf5 \strokec5  node \cf11 \strokec11 tree_to_list\cf5 \strokec5 (\cf10 \strokec10 struct\cf5 \strokec5  Node *root) \{\
    \cf10 \strokec10 return\cf5 \strokec5  make_circular(to_ll(root, \cf12 \strokec12 NULL\cf5 \strokec5 ));\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Reverse-Order Traversal\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is actually a variant of 'right-then-left recursive solution in C' This solution was provided by a candidate, and is a hybrid where we in each traversal pass the node (which at this point represents the left-most node in the list) to the left, after having appended it to the current, passed in head.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 function\cf5 \strokec5  \cf11 \strokec11 recurse\cf5 \strokec5 (\cf15 \strokec15 /*Node*/\cf5 \strokec5  node, \cf15 \strokec15 /*?Node*/\cf5 \strokec5  leftmost) /*\cf11 \strokec11 Node\cf5 \strokec5 */ \{\
    \cf10 \strokec10 if\cf5 \strokec5  (!node) \{\
        \cf10 \strokec10 return\cf5 \strokec5  leftmost;\
    \}\
    \cf10 \strokec10 let\cf5 \strokec5  head = recurse(node.right, leftmost);\
    \cf10 \strokec10 if\cf5 \strokec5  (head) \{\
        head.left = node;\
    \}\
    node.right = head;\
    \cf10 \strokec10 return\cf5 \strokec5  recurse(node.left, node)\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Pure induction (C)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Given a signature of "flatten this tree and produce first and last pointers", the problem can be solved purely inductively taking the left subtree's\'a0
\f2 \cf2 \cb6 \strokec2 last
\f1 \cf2 \cb3 \strokec2 \'a0and writing it into\'a0
\f2 \cf2 \cb6 \strokec2 root->left
\f1 \cf2 \cb3 \strokec2 \'a0and taking the right subtree's\'a0
\f2 \cf2 \cb6 \strokec2 first
\f1 \cf2 \cb3 \strokec2 \'a0and storing it in\'a0
\f2 \cf2 \cb6 \strokec2 root->right
\f1 \cf2 \cb3 \strokec2 . The left recursion and the right recursion are mirrors of eachother, no pointer is ever overwritten, and the solution can be understood in a purely inductive manner.\cb1 \
\cb3 -{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=757368944"}}{\fldrslt \cf4 \strokec4 Tom Jackson}}\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 void\cf5 \strokec5  \cf11 \strokec11 helper\cf5 \strokec5 (Node* root, Node** first, Node** last) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (root->left) \{\
    helper(root->left, first, &root->left);\
    root->left->right = root;\
  \} \cf10 \strokec10 else\cf5 \strokec5  \{\
    *first = root;\
  \}\
\
  \cf10 \strokec10 if\cf5 \strokec5  (root->right) \{\
    helper(root->right, &root->right, last);\
    root->right->left = root;\
  \} \cf10 \strokec10 else\cf5 \strokec5  \{\
    *last = root;\
  \}\
\}\
\
\cf10 \strokec10 void\cf5 \strokec5  \cf11 \strokec11 flatten\cf5 \strokec5 (Node* root, Node** first, Node** last) \{\
  \cf10 \strokec10 if\cf5 \strokec5  (root) \{\
    helper(root, first, last);\
  \} \cf10 \strokec10 else\cf5 \strokec5  \{\
    first = \cf12 \strokec12 nullptr\cf5 \strokec5 ;\
    last = \cf12 \strokec12 nullptr\cf5 \strokec5 ;\
  \}\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Recursive solution in Java\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf10 \cb6 \strokec10 static\cf5 \strokec5  Node treeToList(Node root) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (root == \cf10 \strokec10 null\cf5 \strokec5 ) \{\
      \cf10 \strokec10 return\cf5 \strokec5  \cf10 \strokec10 null\cf5 \strokec5 ;\
    \}\
\
    Node leftList = treeToList(root.left);\
    Node rightList = treeToList(root.right);\
\
    \cf10 \strokec10 return\cf5 \strokec5  combine(combine(leftList, circle(root)), rightList);\
  \}\
\
  
\f3\i \cf14 \strokec14 // input: two circular lists.
\f2\i0 \cf5 \strokec5 \
  
\f3\i \cf14 \strokec14 // output: combined into one circular list and return first list's head
\f2\i0 \cf5 \strokec5 \
  \cf10 \strokec10 static\cf5 \strokec5  Node combine(Node leftHead, Node rightHead) \{\
    \cf10 \strokec10 if\cf5 \strokec5  (leftHead == \cf10 \strokec10 null\cf5 \strokec5 ) \{\
      \cf10 \strokec10 return\cf5 \strokec5  rightHead;\
    \} \cf10 \strokec10 else\cf5 \strokec5  \cf10 \strokec10 if\cf5 \strokec5  (rightHead == \cf10 \strokec10 null\cf5 \strokec5 ) \{\
      \cf10 \strokec10 return\cf5 \strokec5  leftHead;\
    \}\
    
\f3\i \cf14 \strokec14 // now both not null
\f2\i0 \cf5 \strokec5 \
    Node leftTail = leftHead.left;\
    Node rightTail = rightHead.left;\
\
    
\f3\i \cf14 \strokec14 // left head  <-> right tail
\f2\i0 \cf5 \strokec5 \
    leftHead.left = rightTail;\
    rightTail.right = leftHead;\
\
    
\f3\i \cf14 \strokec14 // right head <-> left tail
\f2\i0 \cf5 \strokec5 \
    leftTail.right = rightHead;\
    rightHead.left = leftTail;\
\
    \cf10 \strokec10 return\cf5 \strokec5  leftHead;\
  \}\
\
  
\f3\i \cf14 \strokec14 // transform a non-null single input node into a circle and return it.
\f2\i0 \cf5 \strokec5 \
  \cf10 \strokec10 public\cf5 \strokec5  \cf10 \strokec10 static\cf5 \strokec5  Node circle(Node root)\{\
    root.left = root.right = root;\
    \cf10 \strokec10 return\cf5 \strokec5  root;\
  \}\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 \strokec2 Contributors\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls18\ilvl0
\f1\b0\fs30 \cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=4807591"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Owen Yamauchi}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(creator)\cb1 \
\ls18\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=10105763"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 John Watson}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(solutions, wiki updates)\cb1 \
\ls18\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=1434600058"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Alex Gartrell}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(solutions)\cb1 \
\ls18\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=866410312"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Sean Kinsey}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(solutions)\cb1 \
\ls18\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=1057890118"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Wendy Mu}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(solutions, wiki updates)\cb1 \
\ls18\ilvl0\cf4 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=100000216139342"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Rex Jin}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'a0(solutions)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Ninja Brown Bag\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 (tbd)\cb1 \
}