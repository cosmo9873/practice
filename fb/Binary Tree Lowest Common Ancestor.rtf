{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fswiss\fcharset0 Helvetica-Oblique;
\f3\fswiss\fcharset0 Helvetica;\f4\fswiss\fcharset0 Helvetica-Bold;\f5\fnil\fcharset0 Monaco;
}
{\colortbl;\red255\green255\blue255;\red21\green23\blue25;\red255\green255\blue255;\red52\green56\blue63;
\red78\green84\blue93;\red41\green67\blue135;\red22\green25\blue31;\red54\green59\blue74;\red252\green244\blue202;
\red0\green0\blue0;\red83\green83\blue83;\red0\green0\blue82;\red152\green18\blue15;\red6\green50\blue15;
}
{\*\expandedcolortbl;;\cssrgb\c10980\c11765\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c26667\c28627\c31373;
\cssrgb\c37647\c40392\c43922;\cssrgb\c21176\c34510\c60000;\cssrgb\c11373\c12941\c16078;\cssrgb\c27451\c29804\c36078;\cssrgb\c99216\c96078\c83137;
\cssrgb\c0\c0\c0;\cssrgb\c40000\c40000\c40000;\cssrgb\c0\c3922\c39608;\cssrgb\c66667\c13333\c6667;\cssrgb\c0\c25098\c7059;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Binary Tree Lowest Common Ancestor\
\pard\pardeftab720\sl520\qc\partightenfactor0

\f1\i\fs24 \cf3 \strokec3 \
\pard\pardeftab720\sl520\qc\partightenfactor0
\cf4 \strokec4 \
\pard\pardeftab720\sl520\qc\partightenfactor0

\f0\i0 \cf4 More Items\
\pard\pardeftab720\sl320\partightenfactor0

\f1\b0 \cf5 \strokec5 Owner:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=527466770"}}{\fldrslt \cf6 \strokec6 Bhal Agashe}}\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Medium\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Ninja\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 General\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Description\
\pard\pardeftab720\sl280\partightenfactor0

\f3\b0\fs24 \cf7 \strokec7 Given a well formed binary tree and two nodes in that tree, find the lowest common ancestor of those nodes.\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Question Statement\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\fs36 \cf7 \strokec7 Question\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=908495732606122#question"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 Given a well formed binary tree and two nodes in that tree, find the lowest common ancestor of those nodes.\
\pard\pardeftab720\sl280\partightenfactor0

\f4\b \cf8 \cb9 \strokec8 WARNING:
\f3\b0 \cf7 \strokec7 \'a0This page has serious conflicts in the code sample provided and the description / set-up of the problem. Please do not use this page as a reference until this warning is cleared. Beware, this example deviates from typical LCA where if B is left/right child of A, and LCA of (A, B) is A and not parent of A.\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 \cb1 Notes\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=908495732606122#notes"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls1\ilvl0
\f3\b0\fs24 \cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Most candidates immediately start thinking about this as a search problem. Typical first solutions are DFS based - Find path from root to node1 (P1), from root to node2 (P2) and then find the last common node in P1 & P2. I ask them for obvious flaws in this approach. Good candidates will realize that searching for one node at a time is inefficient. Several candidates will ask if there is a parent pointer available (It becomes too easy if you give a parent pointer). So I tell them, no.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Good candidates will take the mental leap and realize that this can be efficiently solved using a modified post-order traversal of the binary tree. I like to see them thinking in terms of dividing the problem into sub-trees. If I find them struggling, I draw a little, three node tree and ask them how they would go around finding the lowest common ancestor of the two leaf nodes. If they can generalize their solution to three levels, they typically have build a variant of code posted below.\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Code\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=908495732606122#code"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\partightenfactor0

\f5\b0\fs20 \cf10 \cb9 \strokec10 #! /usr/local/bin/python3.3\
\
class Node:\
  def __init__(self, value, left = None, right = None):\
    self.value = value\
    self.left = left\
    self.right = right\
\
# Assumption. It is guaranteed that node1 and node2 are in the tree\
def lowestCommonAncestor(root, node1, node2):\
  if root == None:\
    return [None, 0] #Base case.\
\
  [left_lca, lcount] = lowestCommonAncestor(root.left, node1, node2)\
  [right_lca, rcount] = lowestCommonAncestor(root.right, node1, node2)\
\
  if left_lca != None:\
    # common ancestor has already been found in the left subtree\
    return [left_lca, lcount]\
\
  elif lcount == 2:\
    #\
    #         R ==> R is the lowest common ancestor of A & C.\
    #        / \\\
    #  ---> A   B\
    #      /\
    #     C <---\
    #\
    return [root, lcount]\
\
  if right_lca != None:\
    # common ancestor has already been found in the right subtree\
    return [right_lca, rcount]\
\
  elif rcount == 2:\
    #\
    #         R ==> R is the lowest common ancestor of B & C.\
    #        / \\\
    #       A   B <---\
    #            \\\
    #             C <---\
    #\
    return [root, rcount]\
\
  up_count = lcount + rcount\
  up_node = None\
  if lcount == 1 and rcount == 1:\
    # this is the lowest common ancestor\
    up_node = root\
  else:\
    # check if this node is one of the two nodes\
    if root == node1 or root == node2:\
      up_count += 1\
\
  return [up_node, up_count]\
\
## Wrapper ##\
def findLowestCommonAncestor(root, node1, node2):\
  [lca, _ignore] = lowestCommonAncestor(root, node1, node2)\
  return lca\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\fs24 \cf7 \cb1 \strokec7 cpalow's phone screen prompt\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf11 \cb9 \strokec11 // Find the lowest common ancestor in an unordered binary tree given two values of nodes in the tree.\cf10 \strokec10 \
\
  \cf11 \strokec11 // This is NOT a binary search tree.  The tree is an unordered binary tree.\cf10 \strokec10 \
  \cf11 \strokec11 // Find the lowest/deepest common ancestor of the two nodes represented by val1 and val2.\cf10 \strokec10 \
  \cf11 \strokec11 // In other words, the first value val1 and val2 have in common on their way back up to the root of the tree.\cf10 \strokec10 \
  \cf11 \strokec11 // Another way to described the problem is to find the root of the smallest subtree, as measured by count of nodes, that contains both nodes.\cf10 \strokec10 \
  \cf11 \strokec11 // There is no guarantee that val1 and val2 exist in the tree.  If one value doesn't exist in the tree return NULL or None.\cf10 \strokec10 \
  \cf11 \strokec11 // However, you ARE guaranteed that there are NO duplicate values in the tree and that val1 != val2.\cf10 \strokec10 \
  \cf11 \strokec11 // You can use extra memory, helper functions, and can modify the node struct.\cf10 \strokec10 \
  \cf11 \strokec11 // You have to beat O(N*N) algorithmic complexity for a solution, where N is the number of the nodes in the tree.\cf10 \strokec10 \
  \cf11 \strokec11 // You may use up to O(N) extra memory but no more than O(N) memory.\cf10 \strokec10 \
  \cf11 \strokec11 // There are several ways to solve this problem.  Choose one that is easy for you to get right in the allotted time.\cf10 \strokec10 \
  \cf11 \strokec11 // Generally, correct syntax isn't that important.  Choose any language you're comfortable with.\cf10 \strokec10 \
\
  \cf12 \strokec12 typedef\cf10 \strokec10  \cf12 \strokec12 struct\cf10 \strokec10  \cf12 \strokec12 node_t\cf10 \strokec10  \cf13 \strokec13 \{\cf10 \strokec10 \
	\cf12 \strokec12 struct\cf10 \strokec10  \cf12 \strokec12 node_t\cf10 \strokec10  \cf13 \strokec13 *\cf10 \strokec10  \cf12 \strokec12 left\cf13 \strokec13 ;\cf10 \strokec10 \
	\cf12 \strokec12 struct\cf10 \strokec10  \cf12 \strokec12 node_t\cf10 \strokec10  \cf13 \strokec13 *\cf10 \strokec10  \cf12 \strokec12 right\cf13 \strokec13 ;\cf10 \strokec10 \
	\cf12 \strokec12 int\cf10 \strokec10  \cf12 \strokec12 val\cf13 \strokec13 ;\cf10 \strokec10 \
  \cf13 \strokec13 \}\cf10 \strokec10  \cf12 \strokec12 node\cf13 \strokec13 ;\cf10 \strokec10 \
\
  \cf12 \strokec12 node\cf10 \strokec10  \cf13 \strokec13 *\cf10 \strokec10  \cf14 \strokec14 find_lca\cf13 \strokec13 (\cf12 \strokec12 node\cf10 \strokec10  \cf13 \strokec13 *\cf10 \strokec10  \cf12 \strokec12 root\cf13 \strokec13 ,\cf10 \strokec10  \cf12 \strokec12 int\cf10 \strokec10  \cf12 \strokec12 val1\cf13 \strokec13 ,\cf10 \strokec10  \cf12 \strokec12 int\cf10 \strokec10  \cf12 \strokec12 val2\cf13 \strokec13 )\cf10 \strokec10  \cf13 \strokec13 \{\}\cf10 \strokec10 \
}