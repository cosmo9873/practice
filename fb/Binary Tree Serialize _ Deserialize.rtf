{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fswiss\fcharset0 Helvetica-Oblique;
\f3\fswiss\fcharset0 Helvetica;\f4\fswiss\fcharset0 Helvetica-Bold;\f5\fnil\fcharset0 Monaco;
\f6\fmodern\fcharset0 Courier;\f7\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red21\green23\blue25;\red255\green255\blue255;\red52\green56\blue63;
\red78\green84\blue93;\red41\green67\blue135;\red22\green25\blue31;\red0\green0\blue0;\red252\green244\blue202;
\red152\green18\blue15;\red6\green50\blue15;\red38\green38\blue38;\red228\green230\blue234;\red83\green83\blue83;
\red0\green0\blue82;\red152\green46\blue3;\red12\green95\blue32;\red40\green52\blue164;\red76\green12\blue1;
}
{\*\expandedcolortbl;;\cssrgb\c10980\c11765\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c26667\c28627\c31373;
\cssrgb\c37647\c40392\c43922;\cssrgb\c21176\c34510\c60000;\cssrgb\c11373\c12941\c16078;\cssrgb\c0\c0\c0;\cssrgb\c99216\c96078\c83137;
\cssrgb\c66667\c13333\c6667;\cssrgb\c0\c25098\c7059;\cssrgb\c20000\c20000\c20000;\cssrgb\c91373\c92157\c93333;\cssrgb\c40000\c40000\c40000;
\cssrgb\c0\c3922\c39608;\cssrgb\c66667\c25098\c0;\cssrgb\c0\c43922\c16471;\cssrgb\c20784\c29412\c70196;\cssrgb\c37647\c7059\c0;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid402\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Binary Tree Serialize / Deserialize\
\pard\pardeftab720\sl520\qc\partightenfactor0

\f1\i\fs24 \cf3 \strokec3 \
\pard\pardeftab720\sl520\qc\partightenfactor0
\cf4 \strokec4 \
\pard\pardeftab720\sl520\qc\partightenfactor0

\f0\i0 \cf4 More Items\
\pard\pardeftab720\sl320\partightenfactor0

\f1\b0 \cf5 \strokec5 Owner:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=539338844"}}{\fldrslt \cf6 \strokec6 David Alves}}\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Hard\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Ninja\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Algorithm\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Description\
\pard\pardeftab720\sl280\partightenfactor0

\f3\b0\fs24 \cf7 \strokec7 Given a binary tree of integers, write code to store the tree into a list of integers and recreate the original tree from a list of integers.\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Question Statement\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\fs24 \cf7 \strokec7 Ninja Brown Bag.
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls1\ilvl0\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/hacktv/view/347084505645222"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 11/18/16 Recording}}\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 \
\ls1\ilvl0\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://vod.thefacebook.com/#!/video/11397/Ninja+BB-+Oct+"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 Recording}}\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 \
\ls1\ilvl0\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.facebook.com/internalvideos/videos/791559981055048/"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 4/1/16 Recording}}\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 \
\ls1\ilvl0\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.dropbox.com/s/9sjii482ck9bsgo/Ninja%20BB%20Binary%20Tree%20Serialize-Deserialize.key?dl=0"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 PowerPoint}}\cf7 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 \
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Introduction\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#introduction"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 This is a hard problem. In my experience most candidates will take the entire interview period to finish this question, and many will require hints in order to finish on time.\
I like this question because there are several reasonable solutions and it requires some creativity in designing the serialization format (as opposed to questions where there is really only one good way to do it).\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Problem Statement\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#problem-statement"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 Given a binary tree of integers, write code to store the tree into a list of integers and recreate the original tree from a list of integers.\
Here's what your method signatures should look like (in Java):\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf8 \cb9 \strokec8 List\cf10 \strokec10 <\cf8 \strokec8 Integer\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf8 \strokec8 Node root\cf10 \strokec10 )\cf8 \strokec8 \
Node \cf11 \strokec11 restore\cf10 \strokec10 (\cf8 \strokec8 List\cf10 \strokec10 <\cf8 \strokec8 Integer\cf10 \strokec10 >\cf8 \strokec8  list\cf10 \strokec10 )\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b\fs24 \cf7 \cb1 \strokec7 Notes:
\f3\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls2\ilvl0
\f6 \cf12 \cb13 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec12 restore(store(X))
\f3 \cf7 \cb1 \strokec7 \'a0should return a tree that's identical to\'a0
\f6 \cf12 \cb13 \strokec12 X
\f3 \cf7 \cb1 \strokec7 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls2\ilvl0\cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 There are no restrictions on the shape of the input tree or the values contained in it\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 The list you generate can contain more elements than the tree\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b \cf7 Example Tree
\f3\b0 \
\pard\pardeftab720\sl240\partightenfactor0

\f7\fs22 \cf7 1\
3\
2\
4\
5\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Common Solutions\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#common-solutions"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 All of these solutions are O(N) space and O(N) time, although the constant factor varies.\
When considering these, remember that the empty tree can be represented as an empty list, and that for N nodes there are always N+1 null pointers (see Followup section).\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b \cf7 Depth-first with nulls
\f3\b0 \
A common and simple solution is to do a depth-first preorder traversal of the tree, storing null pointers as nulls in the list. For languages where you can't store nulls in the list, it's fine to relax the constraints by allowing them to choose a special value to represent null (as they can presumably scan the entire tree, identify a value which does not occur in the tree, and then include that value in a header to the list of integers). With this approach the example tree could be stored as [4, 1, 3, null, null, 2, null, null, 5, null, null].\
The length of the list using this approach will be 2N+1 (N for the nodes, N+1 for the nulls).\
Sample:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf14 \cb9 \strokec14 // Author: jkedgar\cf8 \strokec8 \
\cf14 \strokec14 // Note: none of these examples validate that the input does not loop\cf8 \strokec8 \
\cf14 \strokec14 //    nor do they validate that the serialized list is sane during deserialization\cf8 \strokec8 \
\cf14 \strokec14 // Note: this example uses -1 as null value.  If -1 was a valid node value, another\cf8 \strokec8 \
\cf14 \strokec14 // null value would be needed or a different approach used.\cf8 \strokec8 \
\cf14 \strokec14 #define NULL_NODE (-1)\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ,\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 NULL_NODE\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8  \cf16 \strokec16 else\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 val\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 root\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 deserialize\cf10 \strokec10 (\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >::\cf15 \strokec15 const_iterator\cf10 \strokec10 &\cf8 \strokec8  \cf15 \strokec15 it\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 ;\cf8 \strokec8 \
\
  \cf15 \strokec15 int\cf8 \strokec8  \cf15 \strokec15 val\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf10 \strokec10 *(\cf15 \strokec15 it\cf10 \strokec10 ++);\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 val\cf8 \strokec8  \cf10 \strokec10 !=\cf8 \strokec8  \cf15 \strokec15 NULL_NODE\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 new\cf8 \strokec8  \cf17 \strokec17 Node\cf10 \strokec10 (\cf15 \strokec15 val\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 restore\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 auto\cf8 \strokec8  \cf15 \strokec15 it\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b\fs24 \cf7 \cb1 \strokec7 Depth-first with null/non-null flags
\f3\b0 \
You can represent each node by two integers, a flag and a value; and each null pointer by one integer, a flag. The flag is either 0 (to indicate null) or 1 (to indicate a node). If the flag is 0 ("null"), the value is omitted.\
With this approach the example tree would be stored as [1, 4, 1, 1, 1, 3, 0, 0, 1, 2, 0, 0, 1, 5, 0, 0] (value/null-flag version).\
The length of the list is 3N+1 (2N for the nodes, N+1 for the nulls).\
Sample:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf14 \cb9 \strokec14 // Author: jkedgar\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ,\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8  \cf16 \strokec16 else\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf19 \strokec19 1\cf10 \strokec10 );\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 val\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 root\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 deserialize\cf10 \strokec10 (\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >::\cf15 \strokec15 const_iterator\cf10 \strokec10 &\cf8 \strokec8  \cf15 \strokec15 it\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 ;\cf8 \strokec8 \
\
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (*(\cf15 \strokec15 it\cf10 \strokec10 ++)\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf19 \strokec19 1\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 new\cf8 \strokec8  \cf17 \strokec17 Node\cf10 \strokec10 (*(\cf15 \strokec15 it\cf10 \strokec10 ++));\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 restore\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 auto\cf8 \strokec8  \cf15 \strokec15 it\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\fs24 \cf7 \cb1 \strokec7 Here's another sample without using recursion:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf14 \cb9 \strokec14 // Author: jkedgar\cf8 \strokec8 \
\cf14 \strokec14 // Any of the other recursive examples could be converted to not use recursion the same way\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 stack\cf10 \strokec10 <\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *>\cf8 \strokec8  \cf15 \strokec15 stack\cf10 \strokec10 ;\cf8 \strokec8 \
\
  \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (\cf15 \strokec15 root\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 while\cf8 \strokec8  \cf10 \strokec10 (!\cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 empty\cf10 \strokec10 ())\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 top\cf10 \strokec10 ();\cf8 \strokec8 \
    \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 pop\cf10 \strokec10 ();\cf8 \strokec8 \
\
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 );\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8  \cf16 \strokec16 else\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf19 \strokec19 1\cf10 \strokec10 );\cf8 \strokec8 \
      \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 val\cf10 \strokec10 );\cf8 \strokec8 \
      \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf10 \strokec10 );\cf8 \strokec8 \
      \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf10 \strokec10 );\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 restore\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 stack\cf10 \strokec10 <\cf15 \strokec15 Node\cf10 \strokec10 **>\cf8 \strokec8  \cf15 \strokec15 stack\cf10 \strokec10 ;\cf8 \strokec8 \
\
  \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (&\cf15 \strokec15 root\cf10 \strokec10 );\cf8 \strokec8 \
  \cf15 \strokec15 auto\cf8 \strokec8  \cf15 \strokec15 it\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
  \cf16 \strokec16 while\cf8 \strokec8  \cf10 \strokec10 (!\cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 empty\cf10 \strokec10 ())\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 Node\cf10 \strokec10 **\cf8 \strokec8  \cf15 \strokec15 ptr\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 top\cf10 \strokec10 ();\cf8 \strokec8 \
    \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 pop\cf10 \strokec10 ();\cf8 \strokec8 \
\
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (*(\cf15 \strokec15 it\cf10 \strokec10 ++)\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf10 \strokec10 *\cf15 \strokec15 ptr\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 ;\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8  \cf16 \strokec16 else\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf10 \strokec10 *\cf15 \strokec15 ptr\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 new\cf8 \strokec8  \cf17 \strokec17 Node\cf10 \strokec10 (*(\cf15 \strokec15 it\cf10 \strokec10 ++));\cf8 \strokec8 \
      \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (&(*\cf15 \strokec15 ptr\cf10 \strokec10 )->\cf18 \strokec18 right\cf10 \strokec10 );\cf8 \strokec8 \
      \cf15 \strokec15 stack\cf10 \strokec10 .\cf11 \strokec11 push\cf10 \strokec10 (&(*\cf15 \strokec15 ptr\cf10 \strokec10 )->\cf18 \strokec18 left\cf10 \strokec10 );\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b\fs24 \cf7 \cb1 \strokec7 Depth-first with child flags
\f3\b0 \
Each node is represented by two integers, a value and a flag. The flag is a bitmask indicating whether the the node has children (e.g. 1 for has-left, 2 for has-right, and 3 for has-left-and-right).\
With this approach, the example tree would be represented as [4, 3, 1, 3, 3, 0, 2, 0, 5, 0].\
The length of the list is 2N.\
Sample:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf14 \cb9 \strokec14 // Author: jkedgar\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ,\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 !=\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 val\cf10 \strokec10 );\cf8 \strokec8 \
    \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 ((\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf8 \strokec8  \cf10 \strokec10 ?\cf8 \strokec8  \cf19 \strokec19 1\cf8 \strokec8  \cf10 \strokec10 :\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 |\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf8 \strokec8  \cf10 \strokec10 ?\cf8 \strokec8  \cf19 \strokec19 2\cf8 \strokec8  \cf10 \strokec10 :\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 ));\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf10 \strokec10 ,\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 root\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 result\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 deserialize\cf10 \strokec10 (\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >::\cf15 \strokec15 const_iterator\cf10 \strokec10 &\cf8 \strokec8  \cf15 \strokec15 it\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 new\cf8 \strokec8  \cf17 \strokec17 Node\cf10 \strokec10 (*(\cf15 \strokec15 it\cf10 \strokec10 ++));\cf8 \strokec8 \
  \cf15 \strokec15 int\cf8 \strokec8  \cf15 \strokec15 flag\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf10 \strokec10 *(\cf15 \strokec15 it\cf10 \strokec10 ++);\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 flag\cf8 \strokec8  \cf10 \strokec10 &\cf8 \strokec8  \cf19 \strokec19 1\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 flag\cf8 \strokec8  \cf10 \strokec10 &\cf8 \strokec8  \cf19 \strokec19 2\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 restore\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 auto\cf8 \strokec8  \cf15 \strokec15 it\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 it\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 .\cf11 \strokec11 end\cf10 \strokec10 ())\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 it\cf10 \strokec10 );\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b\fs24 \cf7 \cb1 \strokec7 Depth-first with bit-packed null/non-null flags
\f3\b0 \
The structure of the tree is represented by bit-packed null/non-null flags, followed by the node values in depth-first sequence. This can be thought of as equivalent to the "depth-first with null/non-null flags" above, but with the flag bits packed into integer values.\
With this approach (storing the flag bits from right to left), the example tree would be represented as [295, 4, 1, 3, 2, 5] (where 295 = 00100100111, representing the bit flags [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0] from the null/non-null flags encoding above).\
The length of the list is ceil((66N+1)/64) for 64-bit integers, and ceil((34N+1)/32) for 32-bit integers (N for the values, ceil((2N+1)/32) or ceil((2N+1)/64) for the flags).\
This approach is considerably more compact than any of the others, but commensurately trickier to program (on both serialize and deserialize). Note that the "bit-packed flags" and the "node values" sub-lists do not need to be distinguished by any sort of marker or "length header", as the lengths of the two sub-lists can be arithmetically derived from the length of the overall list. A good serializer implementation will make use of a helper object which maintains the two sub-lists internally, and provides "setNextFlag()" and "setNextValue()" methods which insert structure flags and values into their respective lists. A good deserializer implementation will similarly make use of a helper object which internally splits out the two sub-lists, and then provides "getNextFlag()" and "getNextValue()" methods which provide Iterator-like support for the reconstructive depth-first tree traversal.\
Sample:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf14 \cb9 \strokec14 // Author: jkedgar\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 size_t\cf8 \strokec8  \cf15 \strokec15 max_bits\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 sizeof\cf10 \strokec10 (\cf15 \strokec15 int\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 *\cf8 \strokec8  \cf19 \strokec19 8\cf10 \strokec10 ;\cf8 \strokec8 \
\
\cf16 \strokec16 class\cf8 \strokec8  \cf15 \strokec15 SerializeState\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
\cf16 \strokec16 private\cf10 \strokec10 :\cf8 \strokec8 \
  \cf15 \strokec15 uint\cf8 \strokec8  \cf15 \strokec15 tmp\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf15 \strokec15 size_t\cf8 \strokec8  \cf15 \strokec15 bit\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf15 \strokec15 flags\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf15 \strokec15 values\cf10 \strokec10 ;\cf8 \strokec8 \
\
\cf16 \strokec16 public\cf10 \strokec10 :\cf8 \strokec8 \
  \cf11 \strokec11 SerializeState\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 :\cf8 \strokec8  \cf11 \strokec11 tmp\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 ),\cf8 \strokec8  \cf11 \strokec11 bit\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\}\cf8 \strokec8 \
\
  \cf15 \strokec15 inline\cf8 \strokec8  \cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 setNextFlag\cf10 \strokec10 (\cf15 \strokec15 bool\cf8 \strokec8  \cf15 \strokec15 flag\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 flag\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf15 \strokec15 tmp\cf8 \strokec8  \cf10 \strokec10 |=\cf8 \strokec8  \cf19 \strokec19 1\cf15 \strokec15 U\cf8 \strokec8  \cf10 \strokec10 <<\cf8 \strokec8  \cf15 \strokec15 bit\cf10 \strokec10 ;\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
\
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (++\cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 max_bits\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf15 \strokec15 flags\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 ((\cf15 \strokec15 int\cf10 \strokec10 )\cf8 \strokec8  \cf15 \strokec15 tmp\cf10 \strokec10 );\cf8 \strokec8 \
      \cf15 \strokec15 tmp\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 ;\cf8 \strokec8 \
      \cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 ;\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf15 \strokec15 inline\cf8 \strokec8  \cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 setNextValue\cf10 \strokec10 (\cf15 \strokec15 int\cf8 \strokec8  \cf15 \strokec15 value\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8  \cf15 \strokec15 values\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 (\cf15 \strokec15 value\cf10 \strokec10 );\cf8 \strokec8  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf15 \strokec15 inline\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 finalize\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 !=\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf15 \strokec15 flags\cf10 \strokec10 .\cf11 \strokec11 push_back\cf10 \strokec10 ((\cf15 \strokec15 int\cf10 \strokec10 )\cf8 \strokec8  \cf15 \strokec15 tmp\cf10 \strokec10 );\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
\
    \cf15 \strokec15 flags\cf10 \strokec10 .\cf11 \strokec11 splice\cf10 \strokec10 (\cf15 \strokec15 flags\cf10 \strokec10 .\cf11 \strokec11 end\cf10 \strokec10 (),\cf8 \strokec8  \cf15 \strokec15 values\cf10 \strokec10 );\cf8 \strokec8 \
    \cf16 \strokec16 return\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf11 \strokec11 move\cf10 \strokec10 (\cf15 \strokec15 flags\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \};\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 void\cf8 \strokec8  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 SerializeState\cf10 \strokec10 &\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 setNextFlag\cf10 \strokec10 (\cf15 \strokec15 false\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8  \cf16 \strokec16 else\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 setNextFlag\cf10 \strokec10 (\cf15 \strokec15 true\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 setNextValue\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 val\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
    \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf11 \strokec11 store\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf15 \strokec15 Node\cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 root\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 SerializeState\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf11 \strokec11 serialize\cf10 \strokec10 (\cf15 \strokec15 root\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 finalize\cf10 \strokec10 ();\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf16 \strokec16 class\cf8 \strokec8  \cf15 \strokec15 DeserializeState\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
\cf16 \strokec16 private\cf10 \strokec10 :\cf8 \strokec8 \
  \cf15 \strokec15 uint\cf8 \strokec8  \cf15 \strokec15 tmp\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf15 \strokec15 size_t\cf8 \strokec8  \cf15 \strokec15 bit\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >::\cf15 \strokec15 const_iterator\cf8 \strokec8  \cf15 \strokec15 flags\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >::\cf15 \strokec15 const_iterator\cf8 \strokec8  \cf15 \strokec15 values\cf10 \strokec10 ;\cf8 \strokec8 \
\
\cf16 \strokec16 public\cf10 \strokec10 :\cf8 \strokec8 \
  \cf11 \strokec11 DeserializeState\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >\cf8 \strokec8  \cf10 \strokec10 &\cf15 \strokec15 input\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 :\cf8 \strokec8  \cf11 \strokec11 tmp\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 ),\cf8 \strokec8  \cf11 \strokec11 bit\cf10 \strokec10 (\cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 size_t\cf8 \strokec8  \cf15 \strokec15 N\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf10 \strokec10 ((\cf15 \strokec15 input\cf10 \strokec10 .\cf11 \strokec11 size\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 *\cf8 \strokec8  \cf15 \strokec15 max_bits\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 -\cf8 \strokec8  \cf19 \strokec19 1\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 /\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 max_bits\cf8 \strokec8  \cf10 \strokec10 +\cf8 \strokec8  \cf19 \strokec19 2\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 flags\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 input\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
    \cf15 \strokec15 values\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 input\cf10 \strokec10 .\cf11 \strokec11 begin\cf10 \strokec10 ();\cf8 \strokec8 \
    \cf17 \strokec17 std\cf10 \strokec10 ::\cf11 \strokec11 advance\cf10 \strokec10 (\cf15 \strokec15 values\cf10 \strokec10 ,\cf8 \strokec8  \cf15 \strokec15 input\cf10 \strokec10 .\cf11 \strokec11 size\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 -\cf8 \strokec8  \cf15 \strokec15 N\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf15 \strokec15 inline\cf8 \strokec8  \cf15 \strokec15 bool\cf8 \strokec8  \cf11 \strokec11 getNextFlag\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf15 \strokec15 tmp\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 uint\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 *(\cf15 \strokec15 flags\cf10 \strokec10 ++);\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
\
    \cf15 \strokec15 bool\cf8 \strokec8  \cf15 \strokec15 res\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf10 \strokec10 ((\cf15 \strokec15 tmp\cf8 \strokec8  \cf10 \strokec10 >>\cf8 \strokec8  \cf15 \strokec15 bit\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 &\cf8 \strokec8  \cf19 \strokec19 1\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf19 \strokec19 1\cf10 \strokec10 );\cf8 \strokec8 \
    \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (++\cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 ==\cf8 \strokec8  \cf15 \strokec15 max_bits\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
      \cf15 \strokec15 bit\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf19 \strokec19 0\cf10 \strokec10 ;\cf8 \strokec8 \
    \cf10 \strokec10 \}\cf8 \strokec8 \
\
    \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 res\cf10 \strokec10 ;\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf15 \strokec15 inline\cf8 \strokec8  \cf15 \strokec15 int\cf8 \strokec8  \cf11 \strokec11 getNextValue\cf10 \strokec10 ()\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8  \cf16 \strokec16 return\cf8 \strokec8  \cf10 \strokec10 *(\cf15 \strokec15 values\cf10 \strokec10 ++);\cf8 \strokec8  \cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \};\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 DeserializeState\cf10 \strokec10 &\cf8 \strokec8  \cf15 \strokec15 state\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf15 \strokec15 nullptr\cf10 \strokec10 ;\cf8 \strokec8 \
\
  \cf16 \strokec16 if\cf8 \strokec8  \cf10 \strokec10 (\cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 getNextFlag\cf10 \strokec10 ())\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
    \cf15 \strokec15 node\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf16 \strokec16 new\cf8 \strokec8  \cf17 \strokec17 Node\cf10 \strokec10 (\cf15 \strokec15 state\cf10 \strokec10 .\cf11 \strokec11 getNextValue\cf10 \strokec10 ());\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 left\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
    \cf15 \strokec15 node\cf10 \strokec10 ->\cf18 \strokec18 right\cf8 \strokec8  \cf10 \strokec10 =\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
  \cf10 \strokec10 \}\cf8 \strokec8 \
\
  \cf16 \strokec16 return\cf8 \strokec8  \cf15 \strokec15 node\cf10 \strokec10 ;\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf15 \strokec15 Node\cf8 \strokec8  \cf10 \strokec10 *\cf11 \strokec11 restore\cf10 \strokec10 (\cf16 \strokec16 const\cf8 \strokec8  \cf17 \strokec17 std\cf10 \strokec10 ::\cf18 \strokec18 list\cf10 \strokec10 <\cf15 \strokec15 int\cf10 \strokec10 >&\cf8 \strokec8  \cf16 \strokec16 list\cf10 \strokec10 )\cf8 \strokec8  \cf10 \strokec10 \{\cf8 \strokec8 \
  \cf15 \strokec15 DeserializeState\cf8 \strokec8  \cf11 \strokec11 state\cf10 \strokec10 (\cf16 \strokec16 list\cf10 \strokec10 );\cf8 \strokec8 \
  \cf16 \strokec16 return\cf8 \strokec8  \cf11 \strokec11 deserialize\cf10 \strokec10 (\cf15 \strokec15 state\cf10 \strokec10 );\cf8 \strokec8 \
\pard\pardeftab720\sl280\partightenfactor0
\cf10 \strokec10 \}\cf8 \strokec8 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f4\b\fs24 \cf7 \cb1 \strokec7 Pointer swizzling
\f3\b0 \
A slightly more complicated approach is to assign each node an id and then store each node as three integers: value, left-child-id, right-child-id.\
If we number the nodes in depth-first traversal order, with the root node numbered as 1, the example tree would be represented as: [4, 2, 5, 1, 3, 4, 3, 0, 0, 2, 0, 0, 5, 0, 0]\
This approach is equivalent to "depth-first with child flags", except that the left-child and right-child flags are stored in separate values rather than in a bitmask, and the information on which node is the left child and which is the right child is stored redundantly both in the child flags and in the position of the child in the list.\
The length of the list in this version is 3N.\

\f4\b Breadth-first
\f3\b0 \
All of the approaches above can be done with a breadth-first traversal instead of a depth-first traversal, although this a bit harder to get right since it's harder to figure out what the parent of a node is when deserializing.\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Pitfalls\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#pitfalls"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls3\ilvl0
\f3\b0\fs24 \cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Many candidates assume that the length of the list has to be the same as the number of nodes in the tree. I like to state upfront that the list can be longer so that they don't get stuck trying to find an impossible solution.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls4\ilvl0\cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Some candidates are tempted to use the list as an array using heap numbering and store each value in the appropriate place. If they suggest this approach ask them how much space it will use in the worst case. (The answer is O(2^N) for a tree that's shaped like a linked list).\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls5\ilvl0\cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 In languages like Java that don't have pointers to integers, some candidates get confused when writing the recursive deserialize function because they want to pass in the list and an index, but then they need to return both a Node and the new index. Some solutions are:\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl280\partightenfactor0
\ls5\ilvl1\cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Pass in Iterator instead of passing a list and index. The best solution, but very few people think of it\
\ls5\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Make a new class to hold the array and the index to be passed into the function\
\ls5\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Make a new class to hold the two return values\
\ls5\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Introduce a global variable to track the index\
\ls5\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Write an iterative deserialize function\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 How to Evaluate\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#how-to-evaluate"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/wiki/Engineering/Interviewing/Ninja/Ninja_Interview_Generic_Signals/"}}{\fldrslt 
\f3\b0\fs24 \cf6 \strokec6 Generic Ninja Interview Signals}}
\f3\b0\fs24 \
A typical good candidate will think about the problem, try different approaches by hand, and be able to figure out a good approach with only a few broad hints. Once they have their approach in mind they should be able to implement serialize quickly and cleanly with no mistakes. They may have a few issues when coding up deserialize but they should be able to resolve those on their own. It's very rare for a candidate to finish this question early.\
Bad candidates will often start coding immediately without deciding on a format and making sure it works. After they hit a wall, they may require many hints or very specific hints to figure out a serialization format that works. They may have trouble coding up serialize() and usually require many specific hints to code up deserialize().\
\pard\pardeftab720\sl540\sa160\partightenfactor0

\f4\b\fs36 \cf7 Followup\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=925009157577286#followup"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\partightenfactor0

\f3\b0\fs24 \cf7 Ask the candidate how long the list will be for a tree with N elements. For the most common approach (depth-first with nulls), this is a little tricky to figure out. It should be pretty easy for the candidate to give an upper bound (every node has at most 2 null children, so there are at most N nodes + 2N nulls = 3N elements in the list), but they can actually get an exact answer inductively: A tree with one node has two nulls, and every time you add a child you add one node, remove one null, and add two nulls, giving a net of +1 node and +1 null, thus giving a length of 2N+1.\
}