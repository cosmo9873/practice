{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fswiss\fcharset0 Helvetica-Oblique;
\f3\fswiss\fcharset0 Helvetica;\f4\fswiss\fcharset0 Helvetica-Bold;\f5\fnil\fcharset0 Monaco;
}
{\colortbl;\red255\green255\blue255;\red21\green23\blue25;\red255\green255\blue255;\red52\green56\blue63;
\red78\green84\blue93;\red41\green67\blue135;\red22\green25\blue31;\red83\green83\blue83;\red252\green244\blue202;
\red0\green0\blue0;\red0\green0\blue82;\red152\green18\blue15;\red6\green50\blue15;\red152\green46\blue3;
\red40\green52\blue164;\red76\green12\blue1;}
{\*\expandedcolortbl;;\cssrgb\c10980\c11765\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c26667\c28627\c31373;
\cssrgb\c37647\c40392\c43922;\cssrgb\c21176\c34510\c60000;\cssrgb\c11373\c12941\c16078;\cssrgb\c40000\c40000\c40000;\cssrgb\c99216\c96078\c83137;
\cssrgb\c0\c0\c0;\cssrgb\c0\c3922\c39608;\cssrgb\c66667\c13333\c6667;\cssrgb\c0\c25098\c7059;\cssrgb\c66667\c25098\c0;
\cssrgb\c20784\c29412\c70196;\cssrgb\c37647\c7059\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Circular Buffer\
\pard\pardeftab720\sl520\qc\partightenfactor0

\f1\i\fs24 \cf3 \strokec3 \
\pard\pardeftab720\sl520\qc\partightenfactor0
\cf4 \strokec4 \
\pard\pardeftab720\sl520\qc\partightenfactor0

\f0\i0 \cf4 More Items\
\pard\pardeftab720\sl320\partightenfactor0

\f1\b0 \cf5 \strokec5 Owner:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=1036320040"}}{\fldrslt \cf6 \strokec6 Arianna Chessen}}\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Medium\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 Ninja\
\pard\pardeftab720\sl280\partightenfactor0

\f2\i \cf7 \strokec7 \
\pard\pardeftab720\sl320\partightenfactor0

\f1\i0 \cf5 \strokec5 General\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Description\
\pard\pardeftab720\sl280\partightenfactor0

\f3\b0\fs24 \cf7 \strokec7 You want a non-blocking circular queue of bytes.\
\pard\pardeftab720\sl560\partightenfactor0

\f0\b\fs48 \cf2 \strokec2 Question Statement\
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\fs33 \cf7 \strokec7 Target\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#target"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 This question is intended to identify the comfort with which experienced systems candidates accomplish common tasks. It should generally only be used as a phone screen question, because it's probably too easy for an on-site. We're just looking for baseline systems competence here.\
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\b\fs33 \cf7 Question\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#question"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 You want a non-blocking circular queue of bytes. Reads can be of arbitrary length (but should return the max available), writes can be of arbitrary length (but should return the bytes actually written). More or less, the API is exactly the same as a non-blocking queue.\
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\b\fs33 \cf7 Set Up\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#set-up"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 A really good candidate is just going to take the question and run with it if you explain it well, a worse candidate will need to see the API you have in mind. A really bad candidate will need a very thorough explanation -- remember, this is absolutely bread-and-butter systems programming.\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf8 \cb9 \strokec8 // Expected API\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \};\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_init\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_enqueue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf14 \strokec14 const\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 bytes\cf12 \strokec12 );\cf10 \strokec10 \
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_dequeue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 bytes\cf12 \strokec12 );\cf10 \strokec10 \
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\b\fs33 \cf7 \cb1 \strokec7 Ideal Solution\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#ideal-solution"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\partightenfactor0

\f5\b0\fs20 \cf11 \cb9 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 start\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 length\cf12 \strokec12 ;\cf10 \strokec10  \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \};\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_init\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 malloc\cf12 \strokec12 (\cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 ==\cf10 \strokec10  \cf11 \strokec11 NULL\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf14 \strokec14 return\cf10 \strokec10  \cf12 \strokec12 -\cf16 \strokec16 1\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_enqueue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf14 \strokec14 const\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 ==\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf14 \strokec14 return\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 end\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 first_amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 end\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf13 \strokec13 memcpy\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 end\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 first_amt\cf10 \strokec10  \cf12 \strokec12 <\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf13 \strokec13 memcpy\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 data\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 +=\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_dequeue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 ==\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf14 \strokec14 return\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 first_amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf13 \strokec13 memcpy\cf12 \strokec12 (\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 first_amt\cf10 \strokec10  \cf12 \strokec12 <\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf13 \strokec13 memcpy\cf12 \strokec12 (\cf11 \strokec11 data\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 first_amt\cf12 \strokec12 );\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 -=\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\fs24 \cf7 \cb1 \strokec7 The candidate is correctly using memcpy, there's limited extra calculation, no off-by-ones, etc.\
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\b\fs33 \cf7 Less Ideal Solution\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#less-ideal-solution"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\partightenfactor0

\f5\b0\fs20 \cf11 \cb9 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 start\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 length\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \};\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_init\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 malloc\cf12 \strokec12 (\cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf14 \strokec14 if\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf10 \strokec10  \cf12 \strokec12 ==\cf10 \strokec10  \cf11 \strokec11 NULL\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf14 \strokec14 return\cf10 \strokec10  \cf12 \strokec12 -\cf16 \strokec16 1\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_enqueue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf14 \strokec14 const\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf10 \strokec10  \cf12 \strokec12 -\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 end\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 for\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 i\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10  \cf11 \strokec11 i\cf10 \strokec10  \cf12 \strokec12 <\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 ++)\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf12 \strokec12 [(\cf11 \strokec11 end\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ]\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf11 \strokec11 data\cf12 \strokec12 [\cf11 \strokec11 i\cf12 \strokec12 ];\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 +=\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\
\pard\pardeftab720\sl280\partightenfactor0
\cf11 \strokec11 int\cf10 \strokec10  \cf13 \strokec13 queue_dequeue\cf12 \strokec12 (\cf11 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 queue\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 char\cf10 \strokec10  \cf12 \strokec12 *\cf11 \strokec11 data\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 amt\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf13 \strokec13 MIN\cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf12 \strokec12 ,\cf10 \strokec10  \cf11 \strokec11 size\cf12 \strokec12 );\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 for\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 i\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf16 \strokec16 0\cf12 \strokec12 ;\cf10 \strokec10  \cf11 \strokec11 i\cf10 \strokec10  \cf12 \strokec12 <\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 ++)\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
    \cf11 \strokec11 data\cf12 \strokec12 [\cf11 \strokec11 i\cf12 \strokec12 ]\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 data\cf12 \strokec12 [(\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 i\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ];\cf10 \strokec10 \
  \cf12 \strokec12 \}\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 =\cf10 \strokec10  \cf12 \strokec12 (\cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 start\cf10 \strokec10  \cf12 \strokec12 +\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 )\cf10 \strokec10  \cf12 \strokec12 %\cf10 \strokec10  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 size\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 queue\cf12 \strokec12 ->\cf15 \strokec15 length\cf10 \strokec10  \cf12 \strokec12 -=\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf14 \strokec14 return\cf10 \strokec10  \cf11 \strokec11 amt\cf12 \strokec12 ;\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \}\cf10 \strokec10 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\fs24 \cf7 \cb1 \strokec7 The candidate is using for loops instead, though they could potentially get points back if they're making a point about the importance of code simplicity, etc. This code also has a ton of mods and stuff, so they'd need to do something smarter.\
\pard\pardeftab720\sl453\sa160\partightenfactor0

\f4\b\fs33 \cf7 Signs of a Bad Time\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/recruiting/interview/questions/?question_id=799483583520687#signs-of-a-bad-time"}}{\fldrslt \cf6 \strokec6 #}}\
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\b0\fs24 \cf7 The single biggest one is that they try to do something like this:\
\pard\pardeftab720\sl280\partightenfactor0

\f5\fs20 \cf11 \cb9 \strokec11 struct\cf10 \strokec10  \cf11 \strokec11 queue\cf10 \strokec10  \cf12 \strokec12 \{\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 start\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf11 \strokec11 int\cf10 \strokec10  \cf11 \strokec11 end\cf12 \strokec12 ;\cf10 \strokec10 \
  \cf12 \strokec12 ...\cf10 \strokec10 \
\pard\pardeftab720\sl280\partightenfactor0
\cf12 \strokec12 \};\cf10 \strokec10 \
\pard\pardeftab720\sl280\sa240\partightenfactor0

\f3\fs24 \cf7 \cb1 \strokec7 The main problem with that is that it's non-obvious what start == end means (empty or full). Bad candidates will try to dig themselves out of the hole with extra flags or a length field without realizing that the length field is all they need.\
\pard\pardeftab720\sl280\sa240\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/profile/nelno"}}{\fldrslt \cf6 \strokec6 nelno}}\'a0There are at least two ways start / end (head / tail) can be used efficiently:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl280\partightenfactor0
\ls1\ilvl0\cf7 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 Allowing head and tail to monotonically increase and using modulo only when indexing into the buffer or checking boundary conditions (for exampled, if the queue is full), simplifies this solution greatly and also allows for head and tail to be used as metrics (tail is a running count of total number of insertions and head is a running count of total number of removes). If index wrapping is a concern, the queue and dequeue can account for this and reset the counters when appropriate.\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec7 If we're really just maintaining a circular buffer of bytes, just adding one to the length of the allocated buffer allows for ( head == tail ) == empty and ( tail + 1 == head ) == full. This is simpler than keeping an empty or full flag, and probably less data (due to structure packing) unless the candidate uses a bit in one of the other fields. This complicates calculation of the number of items in the queue, however because buffer size - 1 must be used there, while buffer size is used elsewhere for modulo arithmetic.\
\pard\pardeftab720\sl280\partightenfactor0
\cf7 Of course you'll also see people deeply confused about syntax, or running rampant with off-by-ones or missing corner cases.\
}