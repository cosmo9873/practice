{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red147\green0\blue147;
\red249\green249\blue249;\red42\green44\blue51;\red178\green113\blue6;\red66\green147\blue62;\red133\green85\blue4;
}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c65098\c14902\c64314;
\cssrgb\c98039\c98039\c98039;\cssrgb\c21961\c22745\c25882;\cssrgb\c75686\c51765\c392;\cssrgb\c31373\c63137\c30980;\cssrgb\c59608\c40784\c392;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Date Compare\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\fs42 \cf2 Comparing two dates\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is a good warm up question that appears super simple at first glance, but trips people up with unexpected complexity. In general a successful candidate shouldn't spend more than 10-15 minutes on this question, even if they implement both naive and advanced solutions. The signals the question provides:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Does the candidate have a basic knowledge of coding (good for warm up on a phone screen)\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Can the candidate think through problems logically\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Is the candidate happy with ugly code that works\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 \strokec2 Suppose you have two dates and you want to know which comes first. Well, obviously you first compare the year. If the years the same, then compare the month. If they are the same, then compare the date. If the date is the same and there is time involved, you then compare the hours. If those are the same then compare the minutes. If those are the same, then compare the seconds. If those are the same, then compare the milliseconds. And so on.\cb1 \
\cb3 You could also convert the two dates into seconds or milliseconds from some reference date. An easy one is 1/1/00 00:00. Then compare the number for each. Or, you could convert the date into years and some change and compare those.\cb1 \
\cb3 You could also convert the dates into strings of the format "YYYYMMDDHHSS" and then compare them lexicographically.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Python\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Typical setup:\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf4 \cb5 \strokec4 class\cf6 \strokec6  \cf7 \cb5 \strokec7 DateObj\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 object\cf6 \cb5 \strokec6 ):\
    \cf7 \cb5 \strokec7 def\cf6 \cb5 \strokec6  \cf7 \cb5 \strokec7 __init__\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 year\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 month\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 day\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 hour\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 minute\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 second\cf6 \cb5 \strokec6 , \cf7 \cb5 \strokec7 msec\cf6 \cb5 \strokec6 ):\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 year\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 year\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 month\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 month\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 day\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 day\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 hour\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 hour\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 minute\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 minute\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 second\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 second\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 msec\cf6 \cb5 \strokec6  = \cf7 \cb5 \strokec7 int\cf6 \cb5 \strokec6 (\cf7 \cb5 \strokec7 msec\cf6 \cb5 \strokec6 )\
        \cf7 \cb5 \strokec7 self\cf6 \cb5 \strokec6 .\cf7 \cb5 \strokec7 ensure_valid\cf6 \cb5 \strokec6 ()\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Common solutions:\cb1 \
\cb3 People often start with a solution that looks like this because it's the obvious one. It's also horribly ugly and makes for very unmaintainable code.\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 def max_date__nested(d1, d2):\
    \cf4 \strokec4 if\cf6 \strokec6  d1.year > d2.year:\
        \cf4 \strokec4 return\cf6 \strokec6  d1\
    elif d2.year > d1.year:\
        \cf4 \strokec4 return\cf6 \strokec6  d2\
    \cf4 \strokec4 else\cf6 \strokec6 :\
        \cf4 \strokec4 if\cf6 \strokec6  d1.month > d2.month:\
            \cf4 \strokec4 return\cf6 \strokec6  d1\
        elif d2.month > d1.month:\
            \cf4 \strokec4 return\cf6 \strokec6  d2\
    ...\
    \cf4 \strokec4 return\cf6 \strokec6  d1\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This is a solid solution that shows an elegant solution to the problem.\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 def max_date__loops(d1, d2):\
    d1_arr = [d1.year, d1.month, d1.day, ...]\
    d2_arr = [d2.year, d2.month, d2.day, ...]\
\pard\pardeftab720\sl480\partightenfactor0
\cf4 \strokec4 return\cf6 \strokec6  d1 \cf4 \strokec4 if\cf6 \strokec6  d1_arr > d2_arr \cf4 \strokec4 else\cf6 \strokec6  d2\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 A solution that gives good signal but probably shouldn't be accepted is to convert the date object to a "native" python date object and return the largest:\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 def max_date__native(d1, d2):\
    d1_n = datetime.datetime(d1.year, d1.month, ...)\
    d2_n = datetime.datetime(d1.year, d1.month, ...)\
\pard\pardeftab720\sl480\partightenfactor0
\cf4 \strokec4 return\cf6 \strokec6  d1 \cf4 \strokec4 if\cf6 \strokec6  d1_n > d2_n \cf4 \strokec4 else\cf6 \strokec6  d1\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 A lexical sorting solution. This has the advantage of being "always right" and not worrying about calendar oddities. Make sure that the candidate doesn't forget format specifiers so that the strings can actually be compared.\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 def max_date__lexical(d1, d2):\
    d1_str = \cf8 \strokec8 "\{year:04\}-\{month:02\}-\{day:02\} \{hour:02\}:\{minute:02\}:\{second:02\}.\{msec:06\}.format(**d1.__dict__())\
    d2_str = "\cf6 \strokec6 \{year:\cf9 \strokec9 04\cf6 \strokec6 \}-\{month:\cf9 \strokec9 02\cf6 \strokec6 \}-\{day:\cf9 \strokec9 02\cf6 \strokec6 \} \{hour:\cf9 \strokec9 02\cf6 \strokec6 \}:\{minute:\cf9 \strokec9 02\cf6 \strokec6 \}:\{second:\cf9 \strokec9 02\cf6 \strokec6 \}.\{msec:\cf9 \strokec9 06\cf6 \strokec6 \}.format(**d2.__dict__())\
    \cf4 \strokec4 return\cf6 \strokec6  d1 \cf4 \strokec4 if\cf6 \strokec6  d1_str > d2_str \cf4 \strokec4 else\cf6 \strokec6  d1\
}