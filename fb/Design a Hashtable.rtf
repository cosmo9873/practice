{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red42\green44\blue51;
\red249\green249\blue249;}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c21961\c22745\c25882;
\cssrgb\c98039\c98039\c98039;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Design a Hashtable\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 Intro\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\fs30 \cf2 \cb3 \strokec2 I'd recommend not asking this question. It's subtle and really hard to get calibrated on. Seriously, stop reading and find a different question.
\f1\b0 \cf2 \cb1 \strokec2 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Ok, you didn't, I guess continue reading, but buyer be ware.\cb1 \
\cb3 In a lot of ways, this is a very straightforward question, but as a warning to the interviewer, you'll have to pay very close attention to the interview to get the signal you'll need to make a decision on this one. A lot of the signals are pretty subtle here. This question mostly makes sense in C, but also sort of in C++ and Java. Higher level languages get kind of sketchy for this question.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 We often have a need for a fixed-size, evicting hashtable for the purpose of caching query results, memoized values, etc. Design and implement such a hash table.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Evaluation of the Response\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs30 \cf2 \cb3 \strokec2 API\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 \strokec2 You're looking for a reasonable API as well as an implementation that matches their constraints. A strong candidate will isolate a straightforward api with clear memory management semantics. I'd be vague and accept either a void* -> void* or a char* to void* mapping.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf4 \cb5 \strokec4 map_t map_new(int (*key_hash)(void* key), void (*key_compare)(void* key1, void* key2), void (*erase_cb)(void* key, void* value), int size);\
int map_get(void* key);\
int map_set(void* key, void* value);\
int map_erase(void* key);\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 IMPLEMENTATION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 \strokec2 In this, you're looking for all of the common sense stuff: good pointer management, not missing any edge cases with linked lists, etc.\cb1 \
\cb3 If someone is using built-ins, you can either let them ride with it and test their knowledge of common data structures or just cut them off and have them use pointers. It really depends on your feel for their coding, the role, etc.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 DISCUSSION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 \strokec2 At the end of this, if you get a working answer and the person seems to have things under control, you can start talking about the trade offs. From here, you can drive it into concurrency or into performance (cache locality, etc) discussions. Talk at length about tradeoffs. Generally speaking, this is a ninja question, but there's a huge opportunity for Pirate signal so get it if they kill the ninja part.\cb1 \
}