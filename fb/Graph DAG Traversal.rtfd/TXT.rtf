{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier-Oblique;
\f3\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red143\green144\blue150;
\red249\green249\blue249;\red147\green0\blue147;\red42\green44\blue51;\red178\green113\blue6;\red50\green94\blue238;
\red41\green67\blue135;\red133\green85\blue4;}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c62745\c63137\c65490;
\cssrgb\c98039\c98039\c98039;\cssrgb\c65098\c14902\c64314;\cssrgb\c21961\c22745\c25882;\cssrgb\c75686\c51765\c392;\cssrgb\c25098\c47059\c94902;
\cssrgb\c21176\c34510\c60000;\cssrgb\c59608\c40784\c392;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid502\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid8}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Graph DAG Traversal\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\fs42 \cf2 Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Traverse a DAG with unweighted edges and find the shortest path between two nodes.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f0\b \cf2 \cb3 Part I (15 min)
\f1\b0 \'a0Using the provided API, implement a function that takes a graph and prints out each node.\cb1 \

\f0\b \cb3 Part II (25 min)
\f1\b0 \'a0Using the provided API, implement a function that takes a graph, a start node, and a goal node, and returns a list of nodes that corresponds to the shortest path from the start node to the goal node.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 As is the case for any interview question, candidates should be asked to determine the asymptotic complexity of their code for each part.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Provided API\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Give the candidate the following API for an unweighted, directed acyclic graph.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\i \cf4 \cb5 \strokec4 /**\
 * It is not required that candidates discuss this notion of equality, but if you have extra\
 * time, it is good to probe them on this. Unfortunately, this likely requires you to have\
 * specific knowledge of the programming language they are using, as how "equality" is\
 * determined varies from language to language.\
 * \cf6 \strokec6 @param\cf4 \strokec4  <T> The type of object stored as nodes in this graph. Nodes are\
 *     compared for equality via their \{\cf6 \strokec6 @link\cf4 \strokec4  Object#equals(Object)\} method, so\
 *     the behavior of a graph is not specified if the value of a node is\
 *     changed in a manner that affects \{\cf6 \strokec6 @code\cf4 \strokec4  equals\} comparisons while the\
 *     node is a member of the graph.\
 */
\f3\i0 \cf7 \strokec7 \
\pard\pardeftab720\sl480\partightenfactor0
\cf6 \strokec6 interface\cf7 \strokec7  \cf8 \strokec8 DirectedAcyclicGraph\cf7 \strokec7 <\cf8 \strokec8 T\cf7 \strokec7 > \{\
  \cf6 \strokec6 public\cf7 \strokec7  Iterable<T> \cf9 \strokec9 getNodesWithNoIncomingEdges\cf7 \strokec7 ();\
  \cf6 \strokec6 public\cf7 \strokec7  Iterable<T> \cf9 \strokec9 getOutgoingNeighborsFor\cf7 \strokec7 (T node);\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 A good candidate will realize that all of the following scenarios are possible:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The graph is empty (i.e., it contains no nodes).\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The graph is disconnected.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The graph has more than one node with no incoming edges.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Although the API above defines a graph with generic nodes, in practice, candidates are often inclined to redefine the problem in terms of a concrete\'a0
\f3 \cb5 Node
\f1 \cb3 \'a0class. Frequently, the "get neighbors" method gets moved to an instance method of the\'a0
\f3 \cb5 Node
\f1 \cb3 \'a0class in this version of API. Further, especially in untyped languages, the return type is declared as a more concrete type, such as a list:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 interface\cf7 \strokec7  \cf8 \strokec8 Node\cf7 \strokec7  \{\
  \cf6 \strokec6 public\cf7 \strokec7  List<Node> \cf9 \strokec9 getOutgoingNeighbors\cf7 \strokec7 ();\
\}\
\
\cf6 \strokec6 interface\cf7 \strokec7  \cf8 \strokec8 DirectedAcyclicGraph\cf7 \strokec7  \{\
  \cf6 \strokec6 public\cf7 \strokec7  List<Node> \cf9 \strokec9 getNodesWithNoIncomingEdges\cf7 \strokec7 ();\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 I consider this API inferior to the original API, but I would hold off on having this discussion with the candidate until he or she has finished the coding questions. Specifically, the tradeoffs are:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The\'a0
\f3 \cb5 Node
\f1 \cb3 \'a0can only be a member of one\'a0
\f3 \cb5 DirectedAcyclicGraph
\f1 \cb3 \'a0because it must know its own neighbors.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Wrapping each piece of satellite data in a\'a0
\f3 \cb5 Node
\f1 \cb3 \'a0takes up extra memory: just let the satellite data be the node.\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 With a return type like\'a0
\f3 \cb5 List
\f1 \cb3 , one must be more careful about the mutability of the return type.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Finally, here are some Java-specific nuances that are exhibited in the provided API:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Using\'a0
\f3 \cb5 interface
\f1 \cb3 \'a0instead of\'a0
\f3 \cb5 class
\f1 \cb3 , as that allows more flexibility in the implementation.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Returning an\'a0
\f3 \cb5 Iterable
\f1 \cb3 \'a0instead of a specific collection type, as the details of the underlying collection is unimportant. Though admittedly, there are cases where returning a\'a0
\f3 \cb5 Collection
\f1 \cb3 \'a0would be more useful, in general, so you could directly check whether a node is in the collection of outgoing neighbors.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Mentioning or documenting that any\'a0
\f3 \cb5 Iterator
\f1 \cb3 \'a0returned by any of the\'a0
\f3 \cb5 Iterable
\f1 \cb3 s in this API will throw an\'a0
\f3 \cb5 UnsupportedOperationException
\f1 \cb3 \'a0if its\'a0
\f3 \cb5 remove()
\f1 \cb3 \'a0method is invoked.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Part I (15 min): Traversal\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 The most straightforward solution is a depth-first traversal of the graph that starts from the nodes with no incoming edges and has logic to prevent exploring the same node twice. Here is the canonical solution in Python:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 traverse\cf7 \strokec7 (graph):\
  to_explore = []\
  to_explore.extend(graph.get_nodes_with_no_incoming_edges())\
  visited = set()\
  \cf6 \strokec6 while\cf7 \strokec7  to_explore: 
\f2\i \cf4 \strokec4 # More commonly, `while len(to_explore) > 0:`.
\f3\i0 \cf7 \strokec7 \
    node = to_explore.pop()\
    \cf6 \strokec6 if\cf7 \strokec7  node \cf6 \strokec6 in\cf7 \strokec7  visited:\
      \cf6 \strokec6 continue\cf7 \strokec7 \
    \cf6 \strokec6 print\cf7 \strokec7  node\
    visited.add(node)\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      to_explore.append(neighbor)\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Assuming\'a0
\f3 \cb5 graph
\f1 \cb3 \'a0has\'a0
\f3 \cb5 V
\f1 \cb3 \'a0nodes and\'a0
\f3 \cb5 E
\f1 \cb3 \'a0edges, the asymptotic complexity of this implementation is as follows:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400\partightenfactor0
\ls4\ilvl0
\f3 \cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 visited
\f1 \cb3 \'a0will ultimately contain all nodes in the graph, so it is\'a0
\f3 \cb5 O(V)
\f1 \cb3 \'a0in size.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Although\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0expands and contracts over the course of execution, it could have one element per edge in the graph, so it is\'a0
\f3 \cb5 O(E)
\f1 \cb3 \'a0in size.\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Therefore, the total asymptotic complexity in space for this function is\'a0
\f3 \cb5 O(V + E)
\f1 \cb3 .\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For each node and edge in the graph, a constant amount of work is done, so this algorithm is\'a0
\f3 \cb5 O(V + E)
\f1 \cb3 \'a0in time.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Some implementation details to note about this solution:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl400\partightenfactor0
\ls5\ilvl0
\f3 \cf2 \cb5 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 to_explore.extend()
\f1 \cb3 \'a0is used with the result of\'a0
\f3 \cb5 graph.get_nodes_with_no_incoming_edges()
\f1 \cb3 \'a0rather than assigning it directly to\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0or copying the return value using\'a0
\f3 \cb5 [:]
\f1 \cb3 \'a0or some other mechanism. This is cleaner because then\'a0
\f3 \cb5 get_nodes_with_no_incoming_edges()
\f1 \cb3 \'a0can return an iterable, which is less specific than a (possibly mutable) list.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls5\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In Python,\'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fdocs.python.org%2F2%2Ffaq%2Fdesign.html%23how-are-lists-implemented&h=AT2lz43ugiHTPgClF_z5D9z1Dd2vasmKYR2zrQ1FZNC3wTs3bC0Kya2wd67xMtOGccbTP8DjB5gBUmHgxhh1Hr-0QX-JflkGiTz2TOFEzcY6IPAV73Q5SxclTgLZNfo-S5SFk0XQHCBXGlQO2zwxlRGx"}}{\fldrslt \cf10 \strokec10 lists are implemented as variable-length arrays, not linked lists}}, so it is important that\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0is used as a stack rather than a queue. As the function is currently implemented, adding and removing elements to\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0are amortized constant time operations. By comparison, if\'a0
\f3 \cb5 traverse()
\f1 \cb3 \'a0popped elements off the front using\'a0
\f3 \cb5 to_explore.pop(0)
\f1 \cb3 , removal would be an\'a0
\f3 \cb5 O(E)
\f1 \cb3 \'a0operation, so the overall runtime performance would degrade to\'a0
\f3 \cb5 O(V + E^2)
\f1 \cb3 . Note that Python has a\'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fdocs.python.org%2F2%2Flibrary%2Fqueue.html&h=AT2Mw_qYv_aS3GwMNF4KY6l2UTF1Nz5_NIzrklA14R9KnvmQb5DGR4jZ6wGYBxA4VRtmnDv7hKVwySXEc2JB3_vPKcgdpAc1Gjf6YD_2qiefDL5J3-CcfHTyZ8-BIskiptCwjaIs7ybV3DVo_vrBqkx0"}}{\fldrslt \cf10 \strokec10 synchronized FIFO queue}}\'a0that could be used to avoid this problem, though presumably that incurs unnecessary synchronization overhead in this case.\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In my experience, not everyone seems to know that Python has a built-in\'a0
\f3 \cb5 set
\f1 \cb3 . In this case, the candidate often creates a dictionary where keys are nodes and values are booleans. I would not hold this against a candidate unless he or she claims to be an expert in Python.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Further, it is important to recognize that\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0can contain the same node multiple times. For example, consider the following graph:\cb1 \
\
\cb3 Assuming that\'a0
\f3 \cb5 get_outgoing_neighbors_for(A)
\f1 \cb3 \'a0returns\'a0
\f3 \cb5 [B, C]
\f1 \cb3 , then there will be a point when the contents of\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0is\'a0
\f3 \cb5 [B, B]
\f1 \cb3 . This is an important distinction, as the following code will print\'a0
\f3 \cb5 B
\f1 \cb3 \'a0twice if the check for\'a0
\f3 \cb5 in visited
\f1 \cb3 \'a0is moved inside the\'a0
\f3 \cb5 for
\f1 \cb3 \'a0loop:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\i \cf4 \cb5 \strokec4 # Negative example: this code has a bad bug!
\f3\i0 \cf7 \strokec7 \

\f2\i \cf4 \strokec4 # Note the bug will not manifest itself if the input is a tree.
\f3\i0 \cf7 \strokec7 \
\pard\pardeftab720\sl480\partightenfactor0
\cf6 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 traverse_with_duplicate_printing_bug\cf7 \strokec7 (graph):\
  to_explore = []\
  to_explore.extend(graph.get_nodes_with_no_incoming_edges())\
  visited = set()\
  \cf6 \strokec6 while\cf7 \strokec7  to_explore:\
    node = to_explore.pop()\
    
\f2\i \cf4 \strokec4 # BUG! node may have already been visited.
\f3\i0 \cf7 \strokec7 \
    \cf6 \strokec6 print\cf7 \strokec7  node\
    visited.add(node)\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      \cf6 \strokec6 if\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  visited:\
        \cf6 \strokec6 continue\cf7 \strokec7 \
      to_explore.append(neighbor)\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Keep an eye out for this, as it is a common mistake.\cb1 \
\cb3 However, it is possible to implement a working solution where the\'a0
\f3 \cb5 in visited
\f1 \cb3 \'a0check is done inside the\'a0
\f3 \cb5 for
\f1 \cb3 \'a0loop, but that often requires treating the "root nodes" as special case:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 traverse_less_elegant\cf7 \strokec7 (graph):\
  
\f2\i \cf4 \strokec4 # Now the invariant of to_explore is that all of its elements have
\f3\i0 \cf7 \strokec7 \
  
\f2\i \cf4 \strokec4 # already been printed, but its neighbors need to be explored.
\f3\i0 \cf7 \strokec7 \
  to_explore = []\
  visited = set()\
  \cf6 \strokec6 for\cf7 \strokec7  node \cf6 \strokec6 in\cf7 \strokec7  graph.get_nodes_with_no_incoming_edges():\
    \cf6 \strokec6 print\cf7 \strokec7  node\
    to_explore.append(node)\
\
  \cf6 \strokec6 while\cf7 \strokec7  to_explore:\
    node = to_explore.pop()\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      \cf6 \strokec6 if\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  visited:\
        \cf6 \strokec6 continue\cf7 \strokec7 \
      \cf6 \strokec6 print\cf7 \strokec7  neighbor\
      visited.add(neighbor)\
      to_explore.append(neighbor)\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This code does indeed work, though it is less elegant than the canonical solution because the call to print out a node now appears in two places.\cb1 \
\cb3 Finally, it is possible to implement\'a0
\f3 \cb5 traverse()
\f1 \cb3 \'a0such that it maintains the invariant that\'a0
\f3 \cb5 to_explore
\f1 \cb3 \'a0does not contain duplicates by using a set to keep track of what is in\'a0
\f3 \cb5 to_explore
\f1 \cb3 . This improves the asymptotic space of\'a0
\f3 \cb5 traverse()
\f1 \cb3 to\'a0
\f3 \cb5 O(V)
\f1 \cb3 :\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 traverse_with_better_asymptotic_size\cf7 \strokec7 (graph):\
  to_explore = []\
  to_explore.extend(graph.get_nodes_with_no_incoming_edges())\
  in_to_explore = set(to_explore)\
  visited = set()\
\
  \cf6 \strokec6 while\cf7 \strokec7  to_explore:\
    node = to_explore.pop()\
    in_to_explore.remove(node)\
    \cf6 \strokec6 print\cf7 \strokec7  node\
    visited.add(node)\
\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      \cf6 \strokec6 if\cf7 \strokec7  neighbor \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 in\cf7 \strokec7  visited \cf6 \strokec6 and\cf7 \strokec7  neighbor \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 in\cf7 \strokec7  in_to_explore:\
        to_explore.append(neighbor)\
        in_to_explore.add(neighbor)\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This is a heavily-annotated, complete solution in Java using this API:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 interface\cf7 \strokec7  \cf8 \strokec8 DirectedAcyclicGraph\cf7 \strokec7 <\cf8 \strokec8 T\cf7 \strokec7 > \{\
  \cf6 \strokec6 public\cf7 \strokec7  Iterable<T> \cf9 \strokec9 getNodesWithNoIncomingEdges\cf7 \strokec7 ();\
  \cf6 \strokec6 public\cf7 \strokec7  Iterable<T> \cf9 \strokec9 getOutgoingNeighborsFor\cf7 \strokec7 (T node);\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 but with\'a0
\f3 \cb5 T
\f1 \cb3 \'a0restricted to\'a0
\f3 \cb5 Node
\f1 \cb3 . Note that this implementation uses a queue instead of a stack, so it behaves like a breadth-first-search instead of a depth-first-search. Because a\'a0
\f3 \cb5 LinkedList
\f1 \cb3 \'a0is used for the queue, this implementation has\'a0
\f3 \cb5 O(V + E)
\f1 \cb3 \'a0runtime performance, just like the Python implementation using depth-first-search.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 class\cf7 \strokec7  \cf8 \strokec8 Traversal\cf7 \strokec7  \{\
\
  
\f2\i \cf4 \strokec4 /** Utility class: do not instantiate. */
\f3\i0 \cf7 \strokec7 \
  \cf6 \strokec6 private\cf7 \strokec7  \cf9 \strokec9 Traversal\cf7 \strokec7 () \{\}\
\
  \cf6 \strokec6 public\cf7 \strokec7  \cf6 \strokec6 static\cf7 \strokec7  \cf6 \strokec6 void\cf7 \strokec7  \cf9 \strokec9 printNodes\cf7 \strokec7 (DirectedAcyclicGraph<Node> graph) \{\
    
\f2\i \cf4 \strokec4 // This pair of collections could be replaced by a LinkedHashSet, but
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 // the equivalent may not be available in other languages, such as Python.
\f3\i0 \cf7 \strokec7 \
    Queue<Node> nodesToExploreQueue = \cf6 \strokec6 new\cf7 \strokec7  LinkedList<>();\
    Set<Node> nodesToExploreIndex = \cf6 \strokec6 new\cf7 \strokec7  HashSet<>();\
\
    Set<Node> visitedNodes = \cf6 \strokec6 new\cf7 \strokec7  HashSet<>();\
\
    
\f2\i \cf4 \strokec4 // The following would work if getNodesWithNoIncomingEdges() returned a
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 // Collection instead of an Iterable:
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 //
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 //     Collection<Node> startNodes = graph.getNodesWithNoIncomingEdges();
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 //     nodesToExploreQueue.addAll(startNodes);
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 //     nodesToExploreIndex.addAll(startNodes);
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 //
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 // The for loop works just as well, though, and saves an Iterator.
\f3\i0 \cf7 \strokec7 \
    \cf6 \strokec6 for\cf7 \strokec7  (Node node : graph.getNodesWithNoIncomingEdges()) \{\
      nodesToExploreQueue.add(node);\
      nodesToExploreIndex.add(node);\
    \}\
\
    \cf6 \strokec6 while\cf7 \strokec7  (!nodesToExploreQueue.isEmpty()) \{\
      Node node = nodesToExploreQueue.remove();\
      nodesToExploreIndex.remove(node);\
      System.out.println(node);\
      visitedNodes.add(node);\
\
      \cf6 \strokec6 for\cf7 \strokec7  (Node neighbor : graph.getOutgoingNeighborsFor(node)) \{\
        \cf6 \strokec6 if\cf7 \strokec7  (!visitedNodes.contains(neighbor)\
            && !nodesToExploreIndex.contains(neighbor)) \{\
          nodesToExploreQueue.add(neighbor);\
          nodesToExploreIndex.add(neighbor);\
        \}\
      \}\
    \}\
  \}\
\
\} 
\f2\i \cf4 \strokec4 // End class.
\f3\i0 \cf7 \strokec7 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Part II (20 min): Shortest path\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 The general idea behind the solution is to perform a breadth-first-search where the successor to a node is recorded in a map when a node is explored for the first time. When the goal node is explored, a shortest path from the goal back to the start node can be traced through the successor map. This relies on the invariant that,\'a0
\i for a graph with unweighted edges
\i0 , breadth-first-search guarantees that the first time a node is explored in the traversal from a start node, it will be via a shortest path from the start node to the node being explored.\cb1 \
\cb3 As described to the candidate, this problem is deliberately underspecified. The candidate should ideally ask for clarification about the following:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls6\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What should the function return if there is no path from the start node to the goal node? (Note this could also happen if both nodes are not in the graph.) Possible choices:\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl480\partightenfactor0
\ls6\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Return an empty\'a0
\f3 \cb5 List
\f1 \cb3 .\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Return\'a0
\f3 \cb5 null
\f1 \cb3 .\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Make the return type of the method\'a0
\f3 \cb5 Optional<List<T>>
\f1 \cb3 \'a0such that\'a0
\f3 \cb5 Optional.absent()
\f1 \cb3 \'a0would be returned in this case. (This is more appropriate if the user writes in a language with algebraic data types.)\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls7\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If there are multiple shortest paths from the start to the goal, is it acceptable to return any such path from the set? Your answer to this question should be "yes," though you might want to ask the candidate to extend the solution to print all shortest paths, if there is extra time.\cb1 \
\ls7\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If the start and goal nodes are the same, should this return a list that contains only the start node? Again, your answer should be "yes."\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Here is a solution using the generic Java API:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 class\cf7 \strokec7  \cf8 \strokec8 Search\cf7 \strokec7  \{\
\
  
\f2\i \cf4 \strokec4 /** Utility class: do not instantiate. */
\f3\i0 \cf7 \strokec7 \
  \cf6 \strokec6 private\cf7 \strokec7  \cf9 \strokec9 Search\cf7 \strokec7 () \{\}\
\
  
\f2\i \cf4 \strokec4 /**\
   * Finds the shortest path between two nodes in a graph.\
   * <p>\
   * The behavior if this method if either:\
   * <ul>\
   *   <li>Any of the input parameters is \{\cf6 \strokec6 @code\cf4 \strokec4  null\}.\
   *   <li>The start node is not in the graph.\
   * </ul>\
   * \cf6 \strokec6 @return\cf4 \strokec4  non-null list of nodes containing the shortest path from\
   *     \{\cf6 \strokec6 @code\cf4 \strokec4  start\} to \{\cf6 \strokec6 @code\cf4 \strokec4  goal\} in the specified \{\cf6 \strokec6 @code\cf4 \strokec4  graph\}.\
   *     If no such path exists, then an empty list will be returned.\
   */
\f3\i0 \cf7 \strokec7 \
  \cf6 \strokec6 public\cf7 \strokec7  \cf6 \strokec6 static\cf7 \strokec7  <T> List<T> \cf9 \strokec9 findShortestPath\cf7 \strokec7 (\
      DirectedAcyclicGraph<T> graph,\
      T start,\
      T goal) \{\
    
\f2\i \cf4 \strokec4 // Every node in the queue is a key in the nodeToSuccessor map.
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 // When a node is added to the queue, we record the successor that
\f3\i0 \cf7 \strokec7 \
    
\f2\i \cf4 \strokec4 // led us to it.
\f3\i0 \cf7 \strokec7 \
    Queue<T> nodesToExploreQueue = \cf6 \strokec6 new\cf7 \strokec7  LinkedList<>();\
    Map<T, T> nodeToSuccessor = \cf6 \strokec6 new\cf7 \strokec7  HashMap<>();\
    nodesToExploreQueue.add(start);\
    nodeToSuccessor.put(start, \cf6 \strokec6 null\cf7 \strokec7 );\
\
    \cf6 \strokec6 while\cf7 \strokec7  (!nodesToExploreQueue.isEmpty()) \{\
      
\f2\i \cf4 \strokec4 // Remove the node to explore.
\f3\i0 \cf7 \strokec7 \
      T node = nodesToExploreQueue.remove();\
\
      
\f2\i \cf4 \strokec4 // Break to build up the path using the successor map once we have found
\f3\i0 \cf7 \strokec7 \
      
\f2\i \cf4 \strokec4 // the goal node.
\f3\i0 \cf7 \strokec7 \
      \cf6 \strokec6 if\cf7 \strokec7  (node.equals(goal)) \{\
        \cf6 \strokec6 break\cf7 \strokec7 ;\
      \}\
\
      
\f2\i \cf4 \strokec4 // Append the neighbors to the end of the queue if they have not
\f3\i0 \cf7 \strokec7 \
      
\f2\i \cf4 \strokec4 // already been explored.
\f3\i0 \cf7 \strokec7 \
      \cf6 \strokec6 for\cf7 \strokec7  (T neighbor : graph.getOutgoingNeighborsFor(node)) \{\
        \cf6 \strokec6 if\cf7 \strokec7  (!nodeToSuccessor.containsKey(neighbor)) \{\
          nodesToExploreQueue.add(neighbor);\
          nodeToSuccessor.put(neighbor, node);\
        \}\
      \}\
    \}\
\
    \cf6 \strokec6 if\cf7 \strokec7  (!nodeToSuccessor.containsKey(goal)) \{\
      
\f2\i \cf4 \strokec4 // In this case, there is no path from start to goal.
\f3\i0 \cf7 \strokec7 \
      \cf6 \strokec6 return\cf7 \strokec7  Collections.emptyList();\
    \}\
\
    List<T> path = \cf6 \strokec6 new\cf7 \strokec7  ArrayList<>();\
    path.add(goal);\
    T successor = goal;\
    \cf6 \strokec6 while\cf7 \strokec7  ((successor = nodeToSuccessor.get(successor)) != \cf6 \strokec6 null\cf7 \strokec7 ) \{\
      path.add(successor);\
    \}\
\
    Collections.reverse(path);\
    \cf6 \strokec6 return\cf7 \strokec7  path;\
  \}\
\
\} 
\f2\i \cf4 \strokec4 // End class.
\f3\i0 \cf7 \strokec7 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 The candidate must be able to convince you that the invariants of their data structures ensure that:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls8\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Nodes in\'a0
\f3 \cb5 nodesToExploreQueue
\f1 \cb3 \'a0will always be ordered in increasing order with respect to minimum distance from the\'a0
\f3 \cb5 start
\f1 \cb3 \'a0node.\cb1 \
\ls8\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 It follows that the first time\'a0
\f3 \cb5 goal
\f1 \cb3 \'a0is pulled off the queue, its transitive successors stored in the\'a0
\f3 \cb5 nodeToSuccessor
\f1 \cb3 \'a0map constitute a shortest path to\'a0
\f3 \cb5 start
\f1 \cb3 .\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 The asymptotic runtime of this implementation is\'a0
\f3 \cb5 O(V + E)
\f1 \cb3 \'a0while the asymptotic space is\'a0
\f3 \cb5 O(V)
\f1 \cb3 .\cb1 \
\cb3 Recall the note from Part I about it being difficult to implement breadth-first-search in Python because there is no built-in linked list. Therefore, a candidate who is writing in Python is likely to have an initial implementation like the following:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 find_shortest_path\cf7 \strokec7 (graph, start, goal):\
  to_explore = [start]\
  node_to_successor = \{\}\
  node_to_successor[start] = \cf6 \strokec6 None\cf7 \strokec7 \
\
  \cf6 \strokec6 while\cf7 \strokec7  to_explore:\
    
\f2\i \cf4 \strokec4 # This is an O(E) operation in an O(V) loop.
\f3\i0 \cf7 \strokec7 \
    node = to_explore.pop(\cf11 \strokec11 0\cf7 \strokec7 )\
    \cf6 \strokec6 if\cf7 \strokec7  node == goal:\
      \cf6 \strokec6 break\cf7 \strokec7 \
\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      \cf6 \strokec6 if\cf7 \strokec7  neighbor \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 in\cf7 \strokec7  node_to_successor:\
        to_explore.append(neighbor)\
        node_to_successor[neighbor] = node\
\
  \cf6 \strokec6 if\cf7 \strokec7  goal \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 in\cf7 \strokec7  node_to_successor:\
    \cf6 \strokec6 return\cf7 \strokec7  []\
\
  path = [goal]\
  \cf6 \strokec6 while\cf7 \strokec7  \cf6 \strokec6 True\cf7 \strokec7 :\
    successor = node_to_successor.get(path[\cf11 \strokec11 -1\cf7 \strokec7 ])\
    \cf6 \strokec6 if\cf7 \strokec7  successor \cf6 \strokec6 is\cf7 \strokec7  \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 None\cf7 \strokec7 :\
      path.append(successor)\
    \cf6 \strokec6 else\cf7 \strokec7 :\
      \cf6 \strokec6 break\cf7 \strokec7 \
  path.reverse()\
  \cf6 \strokec6 return\cf7 \strokec7  path\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Because of the\'a0
\f3 \cb5 to_explore.pop(0)
\f1 \cb3 \'a0call, the worst-case runtime for this function is\'a0
\f3 \cb5 O(EV)
\f1 \cb3 . If a candidate produces an\'a0
\f3 \cb5 O(EV)
\f1 \cb3 \'a0solution, I would press him or her hard to assess the runtime correctly. If the candidate can do that, then he or she has a shot at producing the optimal solution. In the case of Python, that requires either using a\'a0
\f3 \cb5 Queue
\f1 \cb3 :\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f3 \cf6 \cb5 \strokec6 from\cf7 \strokec7  Queue \cf6 \strokec6 import\cf7 \strokec7  Queue\
\
\cf6 \strokec6 def\cf7 \strokec7  \cf9 \strokec9 find_shortest_path_using_queue\cf7 \strokec7 (graph, start, goal):\
  to_explore = Queue()\
  to_explore.put(start)\
  
\f2\i \cf4 \strokec4 # ...
\f3\i0 \cf7 \strokec7 \
\
  \cf6 \strokec6 while\cf7 \strokec7  \cf6 \strokec6 not\cf7 \strokec7  to_explore.empty():\
    node = to_explore.get()\
    \cf6 \strokec6 if\cf7 \strokec7  node == goal:\
      \cf6 \strokec6 break\cf7 \strokec7 \
\
    \cf6 \strokec6 for\cf7 \strokec7  neighbor \cf6 \strokec6 in\cf7 \strokec7  graph.get_outgoing_neighbors_for(node):\
      \cf6 \strokec6 if\cf7 \strokec7  neighbor \cf6 \strokec6 not\cf7 \strokec7  \cf6 \strokec6 in\cf7 \strokec7  node_to_successor:\
        to_explore.put(neighbor)\
        node_to_successor[neighbor] = node\
  
\f2\i \cf4 \strokec4 # ...
\f3\i0 \cf7 \strokec7 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 or implementing a linked list from scratch and using that.\cb1 \
\cb3 If the candidate does not know about\'a0
\f3 \cb5 Queue
\f1 \cb3 , it will probably be difficult to implement a working linked list in the time remaining in addition to the shortest path function. Therefore, I would not flunk a candidate who can implement the\'a0
\f3 \cb5 O(VE)
\f1 \cb3 \'a0solution in Python and identify the necessary fix to turn it into a\'a0
\f3 \cb5 O(V + E)
\f1 \cb3 \'a0solution, but cannot implement it.\cb1 \
}