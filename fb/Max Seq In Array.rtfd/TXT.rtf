{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red133\green85\blue4;
\red249\green249\blue249;\red42\green44\blue51;\red147\green0\blue147;\red50\green94\blue238;\red41\green67\blue135;
}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c59608\c40784\c392;
\cssrgb\c98039\c98039\c98039;\cssrgb\c21961\c22745\c25882;\cssrgb\c65098\c14902\c64314;\cssrgb\c25098\c47059\c94902;\cssrgb\c21176\c34510\c60000;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Max Seq In Array\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Given an array of integers, find the length of the longest arithmetic sequence in the array. As a reminder, an arithmetic sequence is a sequence where the diff between two consecutive elements is constant. Examples:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf4 \cb5 \strokec4 1\cf6 \strokec6 ,\cf4 \strokec4 3\cf6 \strokec6 ,\cf4 \strokec4 5\cf6 \strokec6 ,\cf4 \strokec4 7\cf6 \strokec6 ,\cf4 \strokec4 9\cf6 \strokec6 \
\cf4 \strokec4 0\cf6 \strokec6 ,\cf4 \strokec4 0\cf6 \strokec6 ,\cf4 \strokec4 0\cf6 \strokec6 ,\cf4 \strokec4 0\cf6 \strokec6 \
\cf4 \strokec4 4\cf6 \strokec6 ,\cf4 \strokec4 1\cf6 \strokec6 ,\cf4 \strokec4 -2\cf6 \strokec6 ,\cf4 \strokec4 -5\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 The elements in the sequence do not need to be consecutive in the array, but their order in the sequence should be the same as it is in the array.\cb1 \
\cb3 For example:\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 [\cf4 \strokec4 1\cf6 \strokec6 ,\cf4 \strokec4 3\cf6 \strokec6 ,\cf4 \strokec4 -20\cf6 \strokec6 ,\cf4 \strokec4 9\cf6 \strokec6 ,\cf4 \strokec4 5\cf6 \strokec6 ,\cf4 \strokec4 7\cf6 \strokec6 ] -> \cf4 \strokec4 4\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 As the longest arithmetic sequence here is 1,3,5,7. Notice that 9 is not part of the sequence, because of its placement in the array.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Solutions\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs30 \cf2 \cb3 NAIVE SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 The naive, "brute force" solution, is to iterate through all pairs in the array \{(i,j) where j > i\}, and then start going forward from j in the array, and find the rest of the elements that could be a part of the sequence. This solution is O(N^3)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs26 \cf2 \cb3 PYTHON\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf7 \cb5 \strokec7 def\cf6 \strokec6  \cf8 \strokec8 maxArithmeticSequenceInArrayLengthSlow\cf6 \strokec6 (arr):\
	length = len(arr)\
	max_len = min(length, \cf4 \strokec4 2\cf6 \strokec6 )\
	\cf7 \strokec7 for\cf6 \strokec6  i \cf7 \strokec7 in\cf6 \strokec6  range(\cf4 \strokec4 0\cf6 \strokec6 , length):\
		\cf7 \strokec7 for\cf6 \strokec6  j \cf7 \strokec7 in\cf6 \strokec6  range(i + \cf4 \strokec4 1\cf6 \strokec6 , length):\
			d = arr[j] - arr[i]\
			next_expected = arr[j] + d\
			curr_len = \cf4 \strokec4 2\cf6 \strokec6 \
			\cf7 \strokec7 for\cf6 \strokec6  k \cf7 \strokec7 in\cf6 \strokec6  range(j + \cf4 \strokec4 1\cf6 \strokec6 , length):\
				k_val = arr[k]\
				\cf7 \strokec7 if\cf6 \strokec6  (k_val == next_expected):\
					curr_len += \cf4 \strokec4 1\cf6 \strokec6 \
					next_expected = d + k_val\
			max_len = max(max_len, curr_len)\
\
	\cf7 \strokec7 return\cf6 \strokec6  max_len\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs26 \cf2 \cb3 \strokec2 JAVA\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf7 \cb5 \strokec7 public\cf6 \strokec6  \cf7 \strokec7 static\cf6 \strokec6  int maxSeqSlow(int[] ints) \{         int max = Math.min(ints.length, \cf4 \strokec4 2\cf6 \strokec6 );        \cf7 \strokec7 for\cf6 \strokec6  (int i = \cf4 \strokec4 0\cf6 \strokec6 ; i < ints.length; i++) \{\
            \cf7 \strokec7 for\cf6 \strokec6  (int j = i+\cf4 \strokec4 1\cf6 \strokec6 ; j < ints.length; j++) \{\
                int diff = ints[j] - ints[i];\
                int next = ints[j] + diff;\
                int counter = \cf4 \strokec4 2\cf6 \strokec6 ;\
                \cf7 \strokec7 for\cf6 \strokec6  (int k = j + \cf4 \strokec4 1\cf6 \strokec6 ; k < ints.length; k++) \{\
                    \cf7 \strokec7 if\cf6 \strokec6  (ints[k] == next) \{\
                        next += diff;\
                        counter++;\
                    \}\
                \}\
                \cf7 \strokec7 if\cf6 \strokec6  (counter > max) \{\
                    max = counter;\
                \}\
            \}\
        \}\
        \cf7 \strokec7 return\cf6 \strokec6  max;\
    \}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 OPTIMAL SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 In the optimal solution we go through all elements in the array (i), for for each element we go through all the elements before (j). Now, we build a hash table for each element. The hashtable key would be the sequence diff and the value would be the sequence length until that element. So now, for each previous element (j) (with the hashtable already built) we search the hashtable based on the diff between the current (i) element and the previous (j) element. If it is found, we place length + 1 in the hashtable of the current (i) element. Otherwise, we place 2. This solution is O(N^2) in time and O(N^2) in memory\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs26 \cf2 \cb3 PYTHON\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb5 \strokec6 length = len(arr)\
mem = []\
ret_max = min(length, \cf4 \strokec4 2\cf6 \strokec6 )\
\pard\pardeftab720\sl480\partightenfactor0
\cf7 \strokec7 for\cf6 \strokec6  i \cf7 \strokec7 in\cf6 \strokec6  range(\cf4 \strokec4 0\cf6 \strokec6 , length):\
	iMem = \{\}\
	mem.append(iMem)\
	\cf7 \strokec7 for\cf6 \strokec6  j \cf7 \strokec7 in\cf6 \strokec6  range (\cf4 \strokec4 0\cf6 \strokec6 , i):\
		jMem = mem[j]\
		d = arr[i] - arr[j]\
		new_len = jMem[d] + \cf4 \strokec4 1\cf6 \strokec6  \cf7 \strokec7 if\cf6 \strokec6  d \cf7 \strokec7 in\cf6 \strokec6  jMem \cf7 \strokec7 else\cf6 \strokec6  \cf4 \strokec4 2\cf6 \strokec6 \
		iMem[d] = new_len\
		ret_max = max(ret_max, new_len)	\
\
\cf7 \strokec7 return\cf6 \strokec6  ret_max\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs26 \cf2 \cb3 \strokec2 JAVA\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf7 \cb5 \strokec7 public\cf6 \strokec6  \cf7 \strokec7 static\cf6 \strokec6  \cf7 \strokec7 int\cf6 \strokec6  \cf8 \strokec8 maxSeq\cf6 \strokec6 (\cf7 \strokec7 int\cf6 \strokec6 [] ints) \{\
        \cf7 \strokec7 if\cf6 \strokec6  (ints.length <= \cf4 \strokec4 2\cf6 \strokec6 ) \{\
            \cf7 \strokec7 return\cf6 \strokec6  ints.length;\
        \}\
\
        List<Map<Integer, Integer>> maps = \cf7 \strokec7 new\cf6 \strokec6  ArrayList<Map<Integer, Integer>>(ints.length);\
\
        \cf7 \strokec7 int\cf6 \strokec6  maxLength = \cf4 \strokec4 2\cf6 \strokec6 ;\
        \cf7 \strokec7 for\cf6 \strokec6  (\cf7 \strokec7 int\cf6 \strokec6  i = \cf4 \strokec4 0\cf6 \strokec6 ; i < ints.length; i++) \{\
            Map<Integer, Integer> iMap = \cf7 \strokec7 new\cf6 \strokec6  HashMap<Integer, Integer>();\
            maps.add(iMap);\
            \cf7 \strokec7 for\cf6 \strokec6  (\cf7 \strokec7 int\cf6 \strokec6  j = \cf4 \strokec4 0\cf6 \strokec6 ; j < i; j++) \{\
                \cf7 \strokec7 int\cf6 \strokec6  diff = ints[i] - ints[j];\
                Map<Integer, Integer> jMap = maps.get(j);\
\
                \cf7 \strokec7 int\cf6 \strokec6  lengthOfDiff;\
                \cf7 \strokec7 if\cf6 \strokec6  (jMap.containsKey(diff)) \{\
                    lengthOfDiff = jMap.get(diff) + \cf4 \strokec4 1\cf6 \strokec6 ;\
                \} \cf7 \strokec7 else\cf6 \strokec6  \{\
                    lengthOfDiff = \cf4 \strokec4 2\cf6 \strokec6 ;\
                \}\
\
                iMap.put(diff, lengthOfDiff);\
\
                \cf7 \strokec7 if\cf6 \strokec6  (lengthOfDiff > maxLength) \{\
                    maxLength = lengthOfDiff;\
                \}\
            \}\
        \}\
\
        \cf7 \strokec7 return\cf6 \strokec6  maxLength;\
    \}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 EVEN MORE OPTIMAL SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \cb3 Note: the greedy algo below does not work. For example, [1 3 5 9 13], it returns 3 instead of 4.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
{\field{\*\fldinst{HYPERLINK "https://our.intern.facebook.com/intern/profile/?id=100000273303568"}}{\fldrslt \cf9 \cb3 \strokec9 Henry Pham}}\cb3 \'a0has actually come up with a more efficient, and perhaps simpler, solution\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf7 \cb5 \strokec7 if\cf6 \strokec6  (len(arr) < \cf4 \strokec4 2\cf6 \strokec6 ):\
	\cf7 \strokec7 return\cf6 \strokec6  len(arr)\
\
	max = \cf4 \strokec4 2\cf6 \strokec6 \
	\cf7 \strokec7 for\cf6 \strokec6  i \cf7 \strokec7 in\cf6 \strokec6  xrange(len(arr)):\
		num_to_len_and_d = dict()\
		first = arr[i] \
		\cf7 \strokec7 for\cf6 \strokec6  j \cf7 \strokec7 in\cf6 \strokec6  xrange(i + \cf4 \strokec4 1\cf6 \strokec6 , len(arr)):\
			second = arr[j]\
			\cf7 \strokec7 if\cf6 \strokec6  (second \cf7 \strokec7 in\cf6 \strokec6  num_to_len_and_d):\
				len_and_d = num_to_len_and_d[second]\
				l = len_and_d[\cf4 \strokec4 0\cf6 \strokec6 ] + \cf4 \strokec4 1\cf6 \strokec6 \
				d = len_and_d[\cf4 \strokec4 1\cf6 \strokec6 ]\
				\cf7 \strokec7 if\cf6 \strokec6  (l > max):\
					max = l\
\
\
			\cf7 \strokec7 else\cf6 \strokec6 :\
				l = \cf4 \strokec4 2\cf6 \strokec6 \
				d = second - first\
\
			num_to_len_and_d[second + d] = (l,d)\
\
	\cf7 \strokec7 return\cf6 \strokec6  max\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This code is still O(n^2) in terms of time complexity, but it is only O(n) in space.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Comparison of the two algorithms\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Out of boredom, I compared the 2 (python) algorithms with increasing sizes of inputs, here is the result (slow being the naive solution, fast being the optimal one).\'a0\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 What to expect\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The part of converting algorithm to code is not trivial, which makes such interviews abundant with coding signals\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 One can say this is a dynamic programming problem. Either way, it is quite difficult to get to the optimal solution in 10-15 mins, and few candidates are able to do it on their own. Still, many problem solving signals can be extracted.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 Given these two, my strategy in such interviews is to help in finding the solution, if needed - but always make sure they write the code for the optimal solution. Most bad candidates fail in the algorithm-code transition part, and so it is quite easy to find the bad coding signals.\cb1 \
}