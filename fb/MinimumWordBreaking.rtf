{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red41\green67\blue135;
\red42\green44\blue51;\red249\green249\blue249;\red147\green0\blue147;\red66\green147\blue62;\red133\green85\blue4;
\red143\green144\blue150;\red50\green94\blue238;\red178\green113\blue6;}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c21176\c34510\c60000;
\cssrgb\c21961\c22745\c25882;\cssrgb\c98039\c98039\c98039;\cssrgb\c65098\c14902\c64314;\cssrgb\c31373\c63137\c30980;\cssrgb\c59608\c40784\c392;
\cssrgb\c62745\c63137\c65490;\cssrgb\c25098\c47059\c94902;\cssrgb\c75686\c51765\c392;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 MinimumWordBreaking\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 Problem Statement\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is an extension for question\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/wiki/Engineering/Interviewing/Ninja/WordBreaking/"}}{\fldrslt \cf4 \strokec4 Word Breaking}}\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf5 \cb6 \strokec5 Given a string S \cf7 \strokec7 and\cf5 \strokec5  a dictionary D of valid words, determine the minimum spaces you could insert\
into the string such that the resulting string would be composed entirely of valid words, \cf7 \strokec7 and\cf5 \strokec5  output the solution.\
\
Example Input\
S = \cf8 \strokec8 "ilikefacebook"\cf5 \strokec5 \
D = [\cf8 \strokec8 "i"\cf5 \strokec5 , \cf8 \strokec8 "like"\cf5 \strokec5 , \cf8 \strokec8 "face"\cf5 \strokec5 , \cf8 \strokec8 "ace"\cf5 \strokec5 , \cf8 \strokec8 "book"\cf5 \strokec5 , \cf8 \strokec8 "facebook"\cf5 \strokec5 ]\
\
Example Output:\
\pard\pardeftab720\sl480\partightenfactor0
\cf8 \strokec8 "i like facebook"\cf5 \strokec5 \
\
Explanation:\
The given string S can be breakable with D in two ways:\
\cf8 \strokec8 "i like face book"\cf5 \strokec5 \
\cf8 \strokec8 "i like facebook"\cf5 \strokec5 \
clearly, the second solution needs the minimum spaces(\cf9 \strokec9 2\cf5 \strokec5 ), so the \cf7 \strokec7 final\cf5 \strokec5  output should be \cf7 \strokec7 as\cf5 \strokec5  shown in above example.\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Overview\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is a medium to hard ninja question which may cover a full ninja interview to come out with a reasonable solution and decent coding.\cb1 \
\
\pard\pardeftab720\sl480\partightenfactor0

\f0\b \cf2 \cb3 Estimated Time:
\f1\b0 \'a035 minutes\cb1 \
\

\f0\b \cb3 Owner:
\f1\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=100001280116836"}}{\fldrslt \cf4 \strokec4 Leo Leqiang Li}}\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Signals & Expectations\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 You should be able to get signal on the below from asking this question. I expect a candidate to get to a working version in around 30-35 minutes, with some hints.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Problem solving\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Algorithmic complexity, trade-offs and optimizations\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Memoization, dynamic programming\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Converting solution to working code\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Understanding & utilization of common data structures\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Testing\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Solutions\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This problem can be split to 2 sub problems:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Find minimum breaking of S given D\cb1 \
\ls2\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Track breaking decision for each step in 1, and output the best solution accordingly\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 For sub problem 1, there are multiple ways:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Divide and conquer: recursively split current S into 2 substring, and find the best split point for current S. Base case: 1) current S is of size 1. 2) current S is a valid word in D. Some sort of cache can prevent re-computation of best solution for S.\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Bottom to up DP. Basically it is a bottom up way of Divide and conquer\cb1 \
\ls3\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Translate the breaking problem to a shortest path in DAG problem. The head before the first letter of S, the tail after the last letter of S and each potential breaking point inside S are the vertex of the DAG, substrings of S which are valid words in D are edges of the DAG. The problem now is to find shortest path from the head vertex to the tail vertex. Apply shortest path algorithm on DAG to find best solution (DFS, Dijkstra, BFS, Pros and Cons)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb3 For sub problem 2, we need record split decision for each step, and output the final solution by backtracing (or simply sort all split points and print substrings accordingly)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 A DIVIDE & CONQUER SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f3\i \cf10 \cb6 \strokec10 #include <stdio.h>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <set>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <string>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <vector>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <cstring>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <map>
\f2\i0 \cf5 \strokec5 \
\
using \cf7 \strokec7 namespace\cf5 \strokec5  \cf11 \strokec11 std\cf5 \strokec5 ;\
\
\pard\pardeftab720\sl480\partightenfactor0
\cf7 \strokec7 class\cf5 \strokec5  \cf12 \strokec12 Split\cf5 \strokec5  \{\
\cf7 \strokec7 public\cf5 \strokec5 :\
  int cuts;\
  int splitPos;\
\
  Split(int c, int s) : cuts(c), splitPos(s) \{\}\
\};\
\
\cf7 \strokec7 class\cf5 \strokec5  \cf12 \strokec12 States\cf5 \strokec5  \{\
\cf7 \strokec7 public\cf5 \strokec5 :\
  map<pair<int, int>, Split> cache;\
\};\
\
int mincut_r(\
    \cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  set<string>& dict,\
    int p, int q, States& states) \{\
  \cf7 \strokec7 if\cf5 \strokec5  (p > q) \{\cf7 \strokec7 return\cf5 \strokec5  \cf9 \strokec9 -1\cf5 \strokec5 ;\}\
\
  auto it = states.cache.find(make_pair(p,q));\
  \cf7 \strokec7 if\cf5 \strokec5  (it != states.cache.end()) \{\
    \cf7 \strokec7 return\cf5 \strokec5  it->second.cuts;\
  \}\
\
  \cf7 \strokec7 if\cf5 \strokec5  (dict.find(str.substr(p, q-p+\cf9 \strokec9 1\cf5 \strokec5 )) != dict.end()) \{\
    states.cache.insert(make_pair(make_pair(p,q), Split(\cf9 \strokec9 0\cf5 \strokec5 ,\cf9 \strokec9 -1\cf5 \strokec5 )));\
    \cf7 \strokec7 return\cf5 \strokec5  \cf9 \strokec9 0\cf5 \strokec5 ;\
  \} \cf7 \strokec7 else\cf5 \strokec5  \{\
    int mincuts = \cf9 \strokec9 -1\cf5 \strokec5 ;\
    int splitPos = \cf9 \strokec9 -1\cf5 \strokec5 ;\
    \cf7 \strokec7 for\cf5 \strokec5  (int s = p ; s < q ; s++) \{\
      int leftcuts = mincut_r(str, dict, p, s, states);\
      int rightcuts = mincut_r(str, dict, s+\cf9 \strokec9 1\cf5 \strokec5 , q, states);\
      \cf7 \strokec7 if\cf5 \strokec5  (leftcuts >= \cf9 \strokec9 0\cf5 \strokec5  && rightcuts >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
        \cf7 \strokec7 if\cf5 \strokec5  (mincuts < \cf9 \strokec9 0\cf5 \strokec5  || mincuts > \cf9 \strokec9 1\cf5 \strokec5  + leftcuts + rightcuts) \{\
          mincuts = \cf9 \strokec9 1\cf5 \strokec5  + leftcuts + rightcuts;\
          splitPos = s;\
        \}\
      \}\
    \}\
    \cf7 \strokec7 if\cf5 \strokec5  (mincuts >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
      states.cache.insert(make_pair(make_pair(p,q), Split(mincuts,splitPos)));\
    \}\
    \cf7 \strokec7 return\cf5 \strokec5  mincuts;\
  \}\
\}\
\
void inorderBackTrack(\cf7 \strokec7 const\cf5 \strokec5  States& states, int p, int q, vector<int>& splits) \{\
  \cf7 \strokec7 if\cf5 \strokec5  (p > q)\{ \cf7 \strokec7 return\cf5 \strokec5 ;\}\
\
  \cf7 \strokec7 const\cf5 \strokec5  auto it = states.cache.find(make_pair(p,q));\
  \cf7 \strokec7 if\cf5 \strokec5  (it == states.cache.end()) \{\cf7 \strokec7 return\cf5 \strokec5 ;\}\
\
  \cf7 \strokec7 if\cf5 \strokec5  (it->second.splitPos < \cf9 \strokec9 0\cf5 \strokec5 ) \{\cf7 \strokec7 return\cf5 \strokec5 ;\}\
\
  inorderBackTrack(states, p, it->second.splitPos, splits);\
  splits.push_back(it->second.splitPos);\
  inorderBackTrack(states, it->second.splitPos + \cf9 \strokec9 1\cf5 \strokec5 , q, splits);\
\}\
\
void mincut(\cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  set<string>& dict) \{\
  States states;\
  int len = str.size();\
  \cf7 \strokec7 if\cf5 \strokec5  (mincut_r(str, dict, \cf9 \strokec9 0\cf5 \strokec5 , len\cf9 \strokec9 -1\cf5 \strokec5 , states) >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
    vector<int> splits;\
    inorderBackTrack(states, \cf9 \strokec9 0\cf5 \strokec5 , len\cf9 \strokec9 -1\cf5 \strokec5 , splits);\
    splits.push_back(len\cf9 \strokec9 -1\cf5 \strokec5 );\
    int p = \cf9 \strokec9 0\cf5 \strokec5 ;\
    \cf7 \strokec7 for\cf5 \strokec5  (vector<int>::iterator it = splits.begin() ; it != splits.end() ; ++it) \{\
      int q = *it;\
      printf(\cf8 \strokec8 "%s "\cf5 \strokec5 , str.substr(p, q-p+\cf9 \strokec9 1\cf5 \strokec5 ).c_str());\
      p = q + \cf9 \strokec9 1\cf5 \strokec5 ;\
    \}\
    printf(\cf8 \strokec8 "\\n"\cf5 \strokec5 );\
  \} \cf7 \strokec7 else\cf5 \strokec5  \{\
    printf(\cf8 \strokec8 "*no solution*\\n"\cf5 \strokec5 );\
  \}\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 A DP SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f3\i \cf10 \cb6 \strokec10 #include <stdio.h>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <set>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <string>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <queue>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <cstring>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #define MAX_LEN 100
\f2\i0 \cf5 \strokec5 \
using \cf7 \strokec7 namespace\cf5 \strokec5  \cf11 \strokec11 std\cf5 \strokec5 ;\
\
void mincut(\cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  set<string>& dict) \{\
  
\f3\i \cf10 \strokec10 /* using dp to find the best solution.\
   * also record split point for each sub-solution*/
\f2\i0 \cf5 \strokec5 \
  \cf7 \strokec7 if\cf5 \strokec5  (str.size() > MAX_LEN) \{\
    printf(\cf8 \strokec8 "string too long\\n"\cf5 \strokec5 );\
    \cf7 \strokec7 return\cf5 \strokec5 ;\
  \}\
  int cut[MAX_LEN][MAX_LEN];\
  int bt[MAX_LEN][MAX_LEN];\
  \cf7 \strokec7 const\cf5 \strokec5  int len = str.size();\
  memset(cut, \cf9 \strokec9 -1\cf5 \strokec5 , sizeof(int) * MAX_LEN * MAX_LEN);\
  memset(bt, \cf9 \strokec9 -1\cf5 \strokec5 , sizeof(int) * MAX_LEN * MAX_LEN);\
\
 \cf7 \strokec7 for\cf5 \strokec5  (int curlen = \cf9 \strokec9 1\cf5 \strokec5  ; curlen <= len ; curlen ++) \{\
    \cf7 \strokec7 for\cf5 \strokec5  (int i = \cf9 \strokec9 0\cf5 \strokec5  ; i + curlen <= len ; i ++) \{\
      int j = i+curlen\cf9 \strokec9 -1\cf5 \strokec5 ;\
      \cf7 \strokec7 if\cf5 \strokec5  (dict.find(str.substr(i, curlen)) != dict.end()) \{\
        cut[i][j] = \cf9 \strokec9 1\cf5 \strokec5 ;\
        bt[i][j] = \cf9 \strokec9 -1\cf5 \strokec5 ;\
      \} \cf7 \strokec7 else\cf5 \strokec5  \{\
        \cf7 \strokec7 for\cf5 \strokec5  (int split = i ; split < j ; split ++) \{\
          \cf7 \strokec7 if\cf5 \strokec5  (cut[i][split] >= \cf9 \strokec9 0\cf5 \strokec5  && cut[split+\cf9 \strokec9 1\cf5 \strokec5 ][j] >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
            \cf7 \strokec7 if\cf5 \strokec5  (cut[i][j] < \cf9 \strokec9 0\cf5 \strokec5  || cut[i][j] > cut[i][split] + cut[split+\cf9 \strokec9 1\cf5 \strokec5 ][j]) \{\
              cut[i][j] = cut[i][split] + cut[split+\cf9 \strokec9 1\cf5 \strokec5 ][j];\
              bt[i][j] = split;\
            \}\
          \}\
        \}\
      \}\
    \}\
  \}\
  \
  
\f3\i \cf10 \strokec10 /* output the best solution using tracking information*/
\f2\i0 \cf5 \strokec5 \
  \cf7 \strokec7 if\cf5 \strokec5  (cut[\cf9 \strokec9 0\cf5 \strokec5 ][len\cf9 \strokec9 -1\cf5 \strokec5 ] < \cf9 \strokec9 0\cf5 \strokec5 ) \{\
    printf(\cf8 \strokec8 "*no solution*\\n"\cf5 \strokec5 );\
    \cf7 \strokec7 return\cf5 \strokec5 ;\
  \}\
  set<int> splits;\
  splits.insert(len\cf9 \strokec9 -1\cf5 \strokec5 );\
  queue<pair<int, int> > sq;\
  sq.push(make_pair(\cf9 \strokec9 0\cf5 \strokec5 , len\cf9 \strokec9 -1\cf5 \strokec5 ));\
  \cf7 \strokec7 while\cf5 \strokec5  (!sq.\cf7 \strokec7 empty\cf5 \strokec5 ()) \{\
    pair<int, int>& cur = sq.front();\
    sq.pop();\
    int cursplit = bt[cur.first][cur.second];\
    \cf7 \strokec7 if\cf5 \strokec5  (cursplit >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
      sq.push(make_pair(cur.first, cursplit));\
      sq.push(make_pair(cursplit+\cf9 \strokec9 1\cf5 \strokec5 , cur.second));\
      splits.insert(cursplit);\
    \}\
  \}\
  int p = \cf9 \strokec9 0\cf5 \strokec5 ;\
  \cf7 \strokec7 for\cf5 \strokec5  (set<int>::iterator it = splits.begin() ; it != splits.end() ; ++it) \{\
    int q = *it;\
    printf(\cf8 \strokec8 "%s "\cf5 \strokec5 , str.substr(p, q-p+\cf9 \strokec9 1\cf5 \strokec5 ).c_str());\
    p = q+\cf9 \strokec9 1\cf5 \strokec5 ;\
  \}\
  printf(\cf8 \strokec8 "\\n"\cf5 \strokec5 );\
\}\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b \cf2 \cb3 \strokec2 A DAG SEARCH SOLUTION\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0 \cf2 \
\pard\pardeftab720\sl480\partightenfactor0

\f3\i \cf10 \cb6 \strokec10 #include <stdio.h>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <map>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <string>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <vector>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <cstring>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <queue>
\f2\i0 \cf5 \strokec5 \

\f3\i \cf10 \strokec10 #include <set>
\f2\i0 \cf5 \strokec5 \
\
using \cf7 \strokec7 namespace\cf5 \strokec5  \cf11 \strokec11 std\cf5 \strokec5 ;\
\
\pard\pardeftab720\sl480\partightenfactor0
\cf7 \strokec7 class\cf5 \strokec5  \cf12 \strokec12 DAG\cf5 \strokec5  \{\
\cf7 \strokec7 public\cf5 \strokec5 :\
  int numVertex;\
  vector<vector<int> > graph;\
\};\
\
void buildDAG(\cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  set<string>& dict, DAG& dag) \{\
  \cf7 \strokec7 if\cf5 \strokec5  (str.\cf7 \strokec7 empty\cf5 \strokec5 ()) \{\cf7 \strokec7 return\cf5 \strokec5 ;\}\
  dag.numVertex = str.size() + \cf9 \strokec9 1\cf5 \strokec5 ;\
  dag.graph.resize(dag.numVertex);\
  \cf7 \strokec7 for\cf5 \strokec5  (int len = \cf9 \strokec9 1\cf5 \strokec5  ; len <= str.size() ; len++) \{\
    \cf7 \strokec7 for\cf5 \strokec5  (int s = \cf9 \strokec9 0\cf5 \strokec5  ; s + len <= str.size() ; s++) \{\
      \cf7 \strokec7 if\cf5 \strokec5  (dict.find(str.substr(s,len)) != dict.end()) \{\
        dag.graph[s].push_back(s+len);\
      \}\
    \}\
  \}\
\}\
\
void searchDAG(\cf7 \strokec7 const\cf5 \strokec5  DAG& dag, map<int, int>& backtrace) \{\
  queue<int> aq;\
  aq.push(\cf9 \strokec9 0\cf5 \strokec5 );\
  \cf7 \strokec7 while\cf5 \strokec5  (!aq.\cf7 \strokec7 empty\cf5 \strokec5 ()) \{\
    int s = aq.front();\
    \cf7 \strokec7 if\cf5 \strokec5  (s == dag.numVertex\cf9 \strokec9 -1\cf5 \strokec5 ) \{\
      \cf7 \strokec7 break\cf5 \strokec5 ;\
    \}\
\
    aq.pop();\
    \cf7 \strokec7 const\cf5 \strokec5  auto ls = dag.graph[s];\
    \cf7 \strokec7 for\cf5 \strokec5  (auto it = ls.begin() ; it != ls.end() ; it ++) \{\
      int t = *it;\
      \cf7 \strokec7 if\cf5 \strokec5  (backtrace.find(t) == backtrace.end()) \{\
        backtrace[t] = s;\
        aq.push(t);\
      \}\
    \}\
  \}\
\}\
\
void printSolution(\cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  map<int, int>& backtrace) \{\
  \cf7 \strokec7 if\cf5 \strokec5  (backtrace.find(str.size()) == backtrace.end()) \{\
    printf(\cf8 \strokec8 "*no solution*\\n"\cf5 \strokec5 );\
    \cf7 \strokec7 return\cf5 \strokec5 ;\
  \}\
\
  vector<int> splits;\
  int cur = str.size();\
  \cf7 \strokec7 while\cf5 \strokec5  (cur >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
    splits.push_back(cur);\
    \cf7 \strokec7 const\cf5 \strokec5  auto it = backtrace.find(cur);\
    cur = (it == backtrace.end()) ? \cf9 \strokec9 -1\cf5 \strokec5  : it->second;\
  \}\
\
  int p = \cf9 \strokec9 -1\cf5 \strokec5 ;\
  \cf7 \strokec7 for\cf5 \strokec5  (auto rit = splits.rbegin() ; rit != splits.rend() ; ++rit) \{\
    \cf7 \strokec7 const\cf5 \strokec5  int q = *rit;\
    \cf7 \strokec7 if\cf5 \strokec5  (p >= \cf9 \strokec9 0\cf5 \strokec5 ) \{\
      printf(\cf8 \strokec8 "%s "\cf5 \strokec5 , str.substr(p, q-p).c_str());\
    \}\
    p = q;\
  \}\
  printf(\cf8 \strokec8 "\\n"\cf5 \strokec5 );\
\}\
\
void mincut(\cf7 \strokec7 const\cf5 \strokec5  string& str, \cf7 \strokec7 const\cf5 \strokec5  set<string>& dict) \{\
  DAG dag;\
  map<int, int> backtrace;\
  buildDAG(str, dict, dag);\
  searchDAG(dag, backtrace);\
  printSolution(str, backtrace);\
\}\
}