{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red254\green195\blue196;
\red41\green67\blue135;\red42\green44\blue51;\red249\green249\blue249;\red147\green0\blue147;\red133\green85\blue4;
}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c100000\c81176\c81176;
\cssrgb\c21176\c34510\c60000;\cssrgb\c21961\c22745\c25882;\cssrgb\c98039\c98039\c98039;\cssrgb\c65098\c14902\c64314;\cssrgb\c59608\c40784\c392;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Remove Zeros From Array\
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 Owner: Andrei Alexandrescu\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb4 \'a0
\f0\b Error!
\f1\b0 \'a0This question has been\'a0{\field{\*\fldinst{HYPERLINK "https://fb.facebook.com/groups/589346821113937/permalink/1641896655858943/"}}{\fldrslt \cf5 \strokec5 deprecated}}. In Oct 2017 it was the most associated question with Facebook interviews. Please do not use this question any more.\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Intro\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Warm-up question, but may take half of the interview. If candidate has serious trouble with it (can't get it off the ground or takes the whole interview working on it), that's strong no hire signal.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\i\b0\fs30 \cf2 \cb3 You are given an array of integers. Write an algorithm that brings all nonzero elements to the left of the array, and returns the number of nonzero elements. The algorithm should operate in place, i.e. shouldn't create a new array. The order of the nonzero elements does not matter. The numbers that remain in the right portion of the array can be anything. Example: given the array [ 1, 0, 2, 0, 0, 3, 4 ], a possible answer is [ 4, 1, 3, 2, ?, ?, ? ], 4 non-zero elements, where "?" can be any number. Code should have good complexity and minimize the number of writes to the array.
\i0 \cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Canonical Answer\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is a baseline intended for comparison purposes. The interviewer should not expect that the candidate writes the canonical answer or a close variation of it. There are many good ways to come to the same results.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 int removeZeros(int[] \cf8 \strokec8 array\cf6 \strokec6 ) \{\
  int left = \cf9 \strokec9 0\cf6 \strokec6 , right = \cf8 \strokec8 array\cf6 \strokec6 .length - \cf9 \strokec9 1\cf6 \strokec6 ;\
  \cf8 \strokec8 while\cf6 \strokec6  (left <= right) \{\
    \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [left] != \cf9 \strokec9 0\cf6 \strokec6 ) ++left;\
    \cf8 \strokec8 else\cf6 \strokec6  \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [right] == \cf9 \strokec9 0\cf6 \strokec6 ) --right;\
    \cf8 \strokec8 else\cf6 \strokec6  \cf8 \strokec8 array\cf6 \strokec6 [left++] = \cf8 \strokec8 array\cf6 \strokec6 [right--];\
  \}\
  \cf8 \strokec8 return\cf6 \strokec6  left;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Objective-C (assuming all objects in the array are NSNumbers with integer values, no NSNulls and no other values)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 NSUInteger removeZeros(NSMutableArray *\cf8 \strokec8 array\cf6 \strokec6 )\
\{\
  \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 .count == \cf9 \strokec9 0\cf6 \strokec6 ) \{\
    \cf8 \strokec8 return\cf6 \strokec6  \cf9 \strokec9 0\cf6 \strokec6 ;\
  \}\
  NSUInteger left = \cf9 \strokec9 0\cf6 \strokec6 ;\
  NSUInteger right = \cf8 \strokec8 array\cf6 \strokec6 .count - \cf9 \strokec9 1\cf6 \strokec6 ;\
  \cf8 \strokec8 while\cf6 \strokec6  (left <= right) \{\
    \cf8 \strokec8 if\cf6 \strokec6  ([\cf8 \strokec8 array\cf6 \strokec6 [left] integerValue] != \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      left++;\
    \} \cf8 \strokec8 else\cf6 \strokec6  \cf8 \strokec8 if\cf6 \strokec6  ([\cf8 \strokec8 array\cf6 \strokec6 [right] integerValue] == \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      \cf8 \strokec8 if\cf6 \strokec6  (right == \cf9 \strokec9 0\cf6 \strokec6 ) \{\
        \cf8 \strokec8 return\cf6 \strokec6  \cf9 \strokec9 0\cf6 \strokec6 ;\
      \}\
      right--;\
    \} \cf8 \strokec8 else\cf6 \strokec6  \{\
      [\cf8 \strokec8 array\cf6 \strokec6  exchangeObjectAtIndex:left++ withObjectAtIndex:right--];\
    \}\
  \}\
  \cf8 \strokec8 return\cf6 \strokec6  left;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Swift version:\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 func moveZeros(inArray \cf8 \strokec8 array\cf6 \strokec6 : inout [Int]) -> Int \{\
  \cf8 \strokec8 var\cf6 \strokec6  left = \cf9 \strokec9 0\cf6 \strokec6 \
  \cf8 \strokec8 var\cf6 \strokec6  right = \cf8 \strokec8 array\cf6 \strokec6 .count - \cf9 \strokec9 1\cf6 \strokec6 \
  \cf8 \strokec8 while\cf6 \strokec6  (left <= right) \{\
    \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [left] != \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      left += \cf9 \strokec9 1\cf6 \strokec6 \
    \} \cf8 \strokec8 else\cf6 \strokec6  \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [right] == \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      right -= \cf9 \strokec9 1\cf6 \strokec6 \
    \} \cf8 \strokec8 else\cf6 \strokec6  \{\
      \cf8 \strokec8 array\cf6 \strokec6 [left] = \cf8 \strokec8 array\cf6 \strokec6 [right]\
      left += \cf9 \strokec9 1\cf6 \strokec6 \
      right -= \cf9 \strokec9 1\cf6 \strokec6 \
    \}\
  \}\
  \cf8 \strokec8 return\cf6 \strokec6  left\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Go (For Go, RemoveZeros returns a new slice backed by the same array as the input):\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 func RemoveZeros(a []int) []int \{\
    l, r := \cf9 \strokec9 0\cf6 \strokec6 , len(a)\cf9 \strokec9 -1\cf6 \strokec6 \
    \cf8 \strokec8 for\cf6 \strokec6  l <= r \{\
        \cf8 \strokec8 if\cf6 \strokec6  a[l] != \cf9 \strokec9 0\cf6 \strokec6  \{\
            l++\
        \} \cf8 \strokec8 else\cf6 \strokec6  \{\
            \cf8 \strokec8 if\cf6 \strokec6  a[r] != \cf9 \strokec9 0\cf6 \strokec6  \{\
                a[l] = a[r]\
                l++\
            \}\
            r--\
        \}\
    \}\
    \cf8 \strokec8 return\cf6 \strokec6  a[\cf9 \strokec9 0\cf6 \strokec6 :l]\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 The code has complexity O(n) and performs in the worst case min(k, n - k) array writes, where n is the total number of elements and k is the number of zeros. The worst case happens when all zeros are at the beginning of the array. The algorithm is\'a0
\i unstable
\i0 \'a0because it changes the relative order of nonzero elements.\cb1 \
\cb3 An alternative solution has the stability property - the order of non-zero elements is preserved. This is suboptimal considering the requirements but many candidates opt for this design:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 int removeZeros(int[] \cf8 \strokec8 array\cf6 \strokec6 ) \{\
  int write = \cf9 \strokec9 0\cf6 \strokec6 ;\
  \cf8 \strokec8 for\cf6 \strokec6  (int read = \cf9 \strokec9 0\cf6 \strokec6 ; read < \cf8 \strokec8 array\cf6 \strokec6 .length; ++read) \{\
    \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [read] != \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      \cf8 \strokec8 if\cf6 \strokec6  (read != write) \{\
        \cf8 \strokec8 array\cf6 \strokec6 [write] = \cf8 \strokec8 array\cf6 \strokec6 [read];\
      \}\
      ++write;\
    \}\
  \}\
  \cf8 \strokec8 return\cf6 \strokec6  write;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This solution has complexity O(n) and does n - k steps in the worst case. Again, the worst case happens when all zeros are at the front of the array.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Discussion\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Very few candidates will write the canonical solution. The typical candidate code is a bit more complicated. e.g.:\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf6 \cb7 \strokec6 int removeZeros(int[] \cf8 \strokec8 array\cf6 \strokec6 ) \{\
  int left = \cf9 \strokec9 0\cf6 \strokec6 , right = \cf8 \strokec8 array\cf6 \strokec6 .length - \cf9 \strokec9 1\cf6 \strokec6 ;\
  \cf8 \strokec8 while\cf6 \strokec6  (left <= right) \{\
    \cf8 \strokec8 if\cf6 \strokec6  (\cf8 \strokec8 array\cf6 \strokec6 [left] != \cf9 \strokec9 0\cf6 \strokec6 ) \{\
      left++;\
    \} \cf8 \strokec8 else\cf6 \strokec6  \{\
      \cf8 \strokec8 while\cf6 \strokec6  (right >= left && \cf8 \strokec8 array\cf6 \strokec6 [right] == \cf9 \strokec9 0\cf6 \strokec6 ) \{\
        right--;\
      \}\
      \cf8 \strokec8 if\cf6 \strokec6  (left <= right) \{\
        \cf8 \strokec8 array\cf6 \strokec6 [left] = \cf8 \strokec8 array\cf6 \strokec6 [right]\
        left++;\
        right--;\
      \}\
    \}\
  \}\
  \cf8 \strokec8 return\cf6 \strokec6  left;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 This follows the thought pattern "iterate the array and when a zero is found, find a nonzero element from the back to replace it".\cb1 \
\cb3 Things to discuss and watch for:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Choosing the right algorithm. First, interviewer must clarify the algorithm is free to reorder the nonzero elements. This is important because it allows for the more efficient algorithm. Does the candidate go with the optimal algorithm that iterates the array from both sides?\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Bounds checking. Many candidates tend to forget all about bounds checking, especially when their code has nested loops (i.e. the outer loop is fine but the inner loops fail to recheck bounds). Suggestion if that happens: ask the candidate, what if you run the algorithm on an array with only zeros or no zeros?\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Wrong handling of the right bound. As a rule of thumb, if the initial right bound is array.length (i.e. one past the last element), the loop guard is left < right. If the initial right bound is array.length - 1, the loop guard is left <= right. Usually candidates use array.length - 1 and left < right. If that happens, ask: let's run the algorithm against an array with exactly one element. Let's try both zero and non-zero. The bug will become apparent. Watch how candidate fixes the bug. Worst case: candidate considers the example a particular case, not the illustration of a deeper issue, and tries to address it before the loop by special casing. There should be no special-case code in the solution.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Quadratic algorithms. Candidate may encode a quadratic solution if the right limit is computed every time (meaning the array is scanned again and again whenever a zero needs to be replaced).\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls5\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use of swap instead of assignment. The interviewer should make it clear that the numbers left in the right-hand portion of the array can be anything. Candidates tend to move the zeros there instead, which makes for twice as many assignments. If that happens, mention to the candidate and see how they fix it.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls6\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Overly complicated solution. If candidate has convoluted code or needs to define additional function, that's negative signal. Many candidates use redundant variables (e.g. define "result" to return it, which is unnecessary). That's weak negative signal.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls7\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Complexity discussion. Ask what's the complexity of the algorithm. Should be O(n) if they got the implementation right. Now ask, given an array with n total elements of which k are equal to zero, (a) where would you put the zeros to achieve the worst case? (Correct answer: at the front of the array); (b) Assuming that worst case, how many assignments does your algorithm do? Correct answer: the stable algorithm does O(n - k) assignments and the unstable algorithm does O(min(k, n - k)) assignments. The more theoretically-inclined candidates may give the right answer immediately or with few hints. For those who give wrong answers, ask them about cases that refute the complexity (classic case: "say you have an array with one million zeros followed by one non-zero element. Your formula dictates that the algorithm makes one million assignments, but in fact it does only one').\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Running code\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Running code is\'a0{\field{\*\fldinst{HYPERLINK "https://fb.facebook.com/groups/einterviewers/permalink/1380979128640476/"}}{\fldrslt \cf5 \strokec5 a somewhat contentious topic}}, but I've gotten good results by allowing candidates to run code during a screening interview. I provide\'a0{\field{\*\fldinst{HYPERLINK "https://phabricator.intern.facebook.com/P57288683"}}{\fldrslt \cf5 \strokec5 a problem statement and test harness}}, which allows the candidate to be sure of correctness provided they write the proper tests. Good candidates will finish the question faster than they would have if they had to think their code through by hand, while bad candidates will keep tacking on more code as they see that their code is wrong.\cb1 \
}