{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red22\green25\blue31;\red255\green255\blue255;\red41\green67\blue135;
\red242\green245\blue249;\red42\green44\blue51;\red249\green249\blue249;\red133\green85\blue4;\red147\green0\blue147;
\red50\green94\blue238;\red208\green208\blue208;\red66\green147\blue62;\red143\green144\blue150;\red178\green113\blue6;
}
{\*\expandedcolortbl;;\cssrgb\c11373\c12941\c16078;\cssrgb\c100000\c100000\c100000;\cssrgb\c21176\c34510\c60000;
\cssrgb\c96078\c96863\c98039;\cssrgb\c21961\c22745\c25882;\cssrgb\c98039\c98039\c98039;\cssrgb\c59608\c40784\c392;\cssrgb\c65098\c14902\c64314;
\cssrgb\c25098\c47059\c94902;\cssrgb\c85098\c85098\c85098;\cssrgb\c31373\c63137\c30980;\cssrgb\c62745\c63137\c65490;\cssrgb\c75686\c51765\c392;
}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid501\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid601\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid602\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid7}
{\list\listtemplateid8\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid701\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid8}
{\list\listtemplateid9\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid801\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid9}
{\list\listtemplateid10\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid901\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid10}
{\list\listtemplateid11\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1001\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid11}
{\list\listtemplateid12\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid12}
{\list\listtemplateid13\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid13}
{\list\listtemplateid14\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1301\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid14}
{\list\listtemplateid15\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1401\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid15}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}{\listoverride\listid9\listoverridecount0\ls9}{\listoverride\listid10\listoverridecount0\ls10}{\listoverride\listid11\listoverridecount0\ls11}{\listoverride\listid12\listoverridecount0\ls12}{\listoverride\listid13\listoverridecount0\ls13}{\listoverride\listid14\listoverridecount0\ls14}{\listoverride\listid15\listoverridecount0\ls15}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl860\partightenfactor0

\f0\b\fs72 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Task Scheduler\
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 Owner:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/profile/?id=100001457314870"}}{\fldrslt \cf4 \strokec4 Marcin Pawlowski}}\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls1\ilvl0
\f0\b \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Ninja Brown Bag Recording:
\f1\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fvod.thefacebook.com%2F%23%21%2Fvideo%2F11555%2FNinja%2BBB%2BTask%2BScheduler&h=AT2Y5bK0LL_NkhBPYGeB-6jrHlgqPKLRMYYV3Gcb_xXG6mxqObPhUMzI51qDp0hv077OwRT7deW0LWReFhwOXDuaqYCp2mhUY2MCyLk0Sz_bdUokCd0bmeOcUk-sM95jNDcXiI6RitaXEgN-nq00EBEO"}}{\fldrslt \cf4 \strokec4 10/26/2015}}\'a0I\'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fvod.thefacebook.com%2F%23%21%2Fvideo%2F12945%2FNinja%2BBB%2BTask%2BScheduler&h=AT0rCLZmrV57Ro31Y1pgzg3Kc2aKRe7wv_fAIsO6pzVzkM5E6sa34AXtzbu2NIMP2ViFWeyGu0-mcwwYdqKifMlWy3yPmUdD7A9BNM7zjAkfsg9wMIFeYoQtey-BI70xUoj8L0emCyj3NUaZGpg2nfZ2"}}{\fldrslt \cf4 \strokec4 2/23/2016}}\cb1 \
\ls1\ilvl0
\f0\b \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 PowerPoint:
\f1\b0 \'a0{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.dropbox.com%2Fs%2Faq2qjttc7569npn%2FNinja%2520BB%2520task%2520scheduling.key%3Fdl%3D0&h=AT2U9K-xfrot3rJhI-jOLHp9TC2WorHO9Z0in3U8AO_9pQPi5osyNgkqFGDy0maABYIpfFHxc8hoMzuZgzvFxuHd_rC4dhIEKYSQa0ke_lq7WJxYSGSMeKN6nvk-ZMhCc33U7nnmAwMS7I8rZLcTVszK"}}{\fldrslt \cf4 \strokec4 https://www.dropbox.com/s/aq2qjttc7569npn/Ninja%20BB%20task%20scheduling.key?dl=0}}\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Hardness:\'a0
\f0\b Medium
\f1\b0 , with a\'a0
\f0\b Hard
\f1\b0 \'a0follow-up.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0
\cf2 \pard\pardeftab720\sl480\partightenfactor0
\cf2 \cb5 \'a0
\f0\b Notice!
\f1\b0 \'a0Please reconsider using this problem. As of Nov 17, 2017, this question is available on:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls3\ilvl0\cf4 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://l.facebook.com/l.php?u=https%3A%2F%2Fleetcode.com%2Fcompany%2Ffacebook%2F&h=AT3VbL88g8yH7iGkJe354Pa59h9MUZjYYV8efytA4PCdm7RJwG7DWD5gmWAXu5i7WJ74Pgu9XFObx7l3F7NOMKV5RNxxvQfBrdjbgeMdNQyTxCFNstGGfv_UFO8PrUDa-jtTzYt1y-bSbHliG8WJhLG5"}}{\fldrslt \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 Leetcode Premium}}\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 , identified as one of the questions Facebook asks most often\'a0\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Target audience\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 This is very universal question. One exception is people who program in C -- no hash maps in the language make it harder to implement. I have not seen a candidate entirely solve both the question and the follow up in 35-40 minutes, so you can assume it will take entire interview. The original version of this question was a bit different (letters used as task type identifiers not numbers) and due to that simpler.\cb1 \
\cb3 The follow up is very hard, requires aha moment and from my experience is mainly good to confirm you are dealing with amazing candidate, but will not tell you much about borderline candidate. In most cases there will be no time to code it all, so you can count on getting at most problem solving signal. Instead I usually go on and ask the candidate to optimize the space usage in basic question (or if the candidate provided solution that is not linear [not solution A] I start hinting at things that are slow and we could make faster). If candidate provides time and space optimal solution and for basic question, carry on to follow up to confirm awesomeness ;-)\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Question Delivery\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\i\b0\fs30 \cf2 \cb3 We have a list of various types of tasks to perform. Task types are identified with an integral identifier: task of type 1, task of type 2, task of type 3, etc. Each task takes 1 time slot to execute, and once we have executed a task we need cooldown (parameter) time slots to recover before we can execute another task of the same type. However, we can execute tasks of other types in the meantime. The recovery interval is the same for all task types. We do not reorder the tasks: always execute in order in which we received them on input.\
Given a list of input tasks to run, and the cooldown interval, output the minimum number of time slots required to run them.
\i0 \cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Examples\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 Example 1\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 \
Recovery interval (cooldown): \cf8 \strokec8 2\cf6 \strokec6 \
Output: \cf8 \strokec8 7\cf6 \strokec6   (order is \cf8 \strokec8 1\cf6 \strokec6  _ _ \cf8 \strokec8 1\cf6 \strokec6  \cf8 \strokec8 2\cf6 \strokec6  _ \cf8 \strokec8 1\cf6 \strokec6 )\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 \strokec2 Example 2\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 \
Recovery interval (cooldown): \cf8 \strokec8 3\cf6 \strokec6 \
Output: \cf8 \strokec8 7\cf6 \strokec6   (order is \cf8 \strokec8 1\cf6 \strokec6  \cf8 \strokec8 2\cf6 \strokec6  \cf8 \strokec8 3\cf6 \strokec6  _ \cf8 \strokec8 1\cf6 \strokec6  \cf8 \strokec8 2\cf6 \strokec6  \cf8 \strokec8 3\cf6 \strokec6 )\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Note: This example can surface bugs due to tracking the original index instead of the output index. You might want to save this and see if the candidate can notice the issue on their own, then pull this out as a counterexample if they need a hint.\
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 Example 3\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6  ,\cf8 \strokec8 4\cf6 \strokec6 , \cf8 \strokec8 5\cf6 \strokec6 , \cf8 \strokec8 6\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 , \cf8 \strokec8 6\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 \
Recovery interval (cooldown): \cf8 \strokec8 6\cf6 \strokec6 \
Output: \cf8 \strokec8 18\cf6 \strokec6   (\cf8 \strokec8 1\cf6 \strokec6  \cf8 \strokec8 2\cf6 \strokec6  \cf8 \strokec8 3\cf6 \strokec6  \cf8 \strokec8 4\cf6 \strokec6  \cf8 \strokec8 5\cf6 \strokec6  \cf8 \strokec8 6\cf6 \strokec6  _ _ \cf8 \strokec8 2\cf6 \strokec6  _ \cf8 \strokec8 4\cf6 \strokec6  _ \cf8 \strokec8 6\cf6 \strokec6  \cf8 \strokec8 1\cf6 \strokec6  _ \cf8 \strokec8 2\cf6 \strokec6  _ \cf8 \strokec8 4\cf6 \strokec6 )\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Note: these examples were selected to cover some tricky cases that often trigger off-by-one in candidate's solution. It takes time to show them, but later on you can see if candidate thought about covering them. Example 3 is a bit excessive but showing first and second is a good start.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Solutions\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 The most fundamental observation that candidate should make is: recognize that input indexes and output indexes should be treated independently (we cannot use position in the input to check what is the next available spot for the task, or at least not easily). It often takes time for candidate to notice that, do not hint too early.\cb1 \
\cb3 There is one common idea for all the solutions: they assume that when we cannot execute a task, we jump directly to place in output space where we can execute. I've seen lots of candidates just skip on position and try next one until we can execute task. This behavior multiplies execution time by\'a0
\f0\b cooldown
\f1\b0 \'a0ie\'a0
\f0\b O(N)\'a0
\f1\b0 becomes\'a0
\f0\b O(N*cooldown)
\f1\b0 ,\'a0
\f0\b O(N*cooldown)
\f1\b0 \'a0becomes\'a0
\f0\b O(N*cooldown^2
\f1\b0 ) There are 3 solutions that I commonly see:\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 (A) Hash Table of Last/Next Execution Time\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Create a hash table storing the most recent time that each task type was executed. (Or equivalently, add the cooldown to these values and track the next time the task type is allowed to be executed.)\cb1 \
\cb3 This allows you to easily compute if a given task may be executed, or how many cooldown slots must be insert.\cb1 \
\cb3 Time complexity is\'a0
\f0\b O(N)
\f1\b0 , and requires\'a0
\f0\b O(num_task_types)
\f1\b0 \'a0storage.\cb1 \
\cb3 This solution can be optimized to use memory\'a0
\f0\b O(min(num_task_type, cooldown_time))
\f1\b0 . Once candidate is done with basic version, it is time to hint to optimize the memory. There are 2 ways to achieve optimal memory complexity:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Iterate over entire hash map every cooldown steps and delete unneeded entries\cb1 \
\ls4\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Keep a queue of tasks in hash map and pop/push in each iteration deleting from hash map\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 (B) Hash Table of Cooldown Time\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Some candidates use a hash table, but instead of tracking the last executed time, they track how many slots remain before the task can be updated. When a task is executed, they insert the cooldown interval into the hash table. Each iteration they decrement all of the values in the hash table.\cb1 \
\cb3 Time complexity is\'a0
\f0\b O(N * cooldown)
\f1\b0 , and requires\'a0
\f0\b O(cooldown)
\f1\b0 \'a0storage. If the candidate doesn't eliminate 0 entries from the map it requires\'a0
\f0\b O(N * cooldown)
\f1\b0 \'a0time and\'a0
\f0\b O(num_task_types)
\f1\b0 \'a0storage.\cb1 \
\cb3 Alternatively, some candidates track the number of slots since the task was last executed, rather than the number of slots remaining before the task can be excuted again.\cb1 \
\cb3 Once candidate arrives at such solution, verifies correctness, interviewer should ask if it is possible to make the solution faster (hinting at solution A).\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 (C) Queue of Last Cooldown Tasks\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Store a queue containing the last several tasks executed. Exactly cooldown slots need to be tracked. When checking if a new task can be executed walk backwards through the queue to see if the task type is present in the queue.\cb1 \
\cb3 Time complexity is\'a0
\f0\b O(N * cooldown)
\f1\b0 , and requires\'a0
\f0\b O(cooldown)
\f1\b0 \'a0storage.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Hiring evaluation\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 No Hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls5\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Never resolves the confusion between input indices and output indices\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 After hints resolves the confusion but is unable to produce working solution\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Needs hints to recognize complexity + needs counter examples to resolve bugs, never progress to optimizing time/space\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate is never able to eliminate the cooldown multipliers mentioned in solutions paragraph, even though candidate is hinted and has time for it\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: Candidate needs hints to arrive at any of the solutions and interviewer needs to show bug (after first trying to show just counterexample)\cb1 \
\ls5\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: Candidate fixes code in response to counterexamples not caring about entirely changing the meaning of the code (breaking previously tested cases)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Maybe Hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls6\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate arrives at a solution, but needs hints to get over some cases\cb1 \
\ls6\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate arrives at a solution, but needs strong hints to overcome cooldown multiplier\cb1 \
\ls6\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate produces a solution using queue which has small bug (getting this right is usually hard), but you could expect with little more time that would get fixed (this is judgement call)\cb1 \
\ls6\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate produces a correct solution but has hard time progressing to optimize it in any way\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls7\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidate produces correct solution and optimizes it:\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl480\partightenfactor0
\ls7\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Finds and understands bugs quickly\cb1 \
\ls7\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Understands the complexity of solution\cb1 \
\ls7\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If arrives at solution with cooldown multipliers, notices (maybe with small hint) how causes complexity blow up and fixes quickly\cb1 \
\ls7\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If arrives at solution that is slower then optimal, acts on hints to get to linear time\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls7\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Beautiful solution using queue\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Strong Hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls8\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Correctly writes the solution with queue and optimizes to linear (queue solution is the hardest to get the code right)\cb1 \
\ls8\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Quickly arrives at linear solution and notices that space can be optimized and how (with implementation)\cb1 \
\ls8\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Picks good test and goes though the solution\cb1 \
\ls8\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Understand complexity at every stage of his or her solution\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Absolute hire\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls9\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Solves the follow up (in code not only proposing the solution) -- I have not seen anyone really finish it\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Signal\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Notes applicable to any question:\'a0{\field{\*\fldinst{HYPERLINK "https://our.internmc.facebook.com/intern/wiki/Engineering/Interviewing/Ninja/Ninja_Interview_Generic_Signals/"}}{\fldrslt \cf4 \strokec4 Engineering/Interviewing/Ninja/Ninja_Interview_Generic_Signals}}\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Non signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls10\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Takes longer than expected (should be one check) to figure out the exact equation for jump -- everyone can get nervous, happens pretty often ;-)\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Common Positive Signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls11\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Recognizes the difference between input indices and output indices\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 From the beginning thinks about complexity\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Solves the equation for cooldown time with small example\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Sticks to one meaning of index position (is it the position of task that already have been executed or position of the next task to be executed)\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Explains what hash table stores\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If produced a solution that introduces the cooldown multiplicative factor, is able to show example input where this causes explosion\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: Eliminates unneeded code and conditions (maybe after some time looking and noticing it is not needed)\cb1 \
\ls11\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: Picks nice test cases and follows them thoroughly\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Common Negative Signal\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls12\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Does not distinguish input and output indices\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Cannot solve the equation for wait times\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Changes the meaning of current index (trial and error coding again)\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Incorrectly handles beginning of the input\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Gets lost while implementing queue and realizes it can be done with hash table but is not clear on that either\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: starts coding before understanding what needs to be done\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: (trial and error coding) when faced with counterexample fixes it without looking at how it changes the meaning of code (breaking other examples)\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: Tests incorrectly\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: off-by-ones\cb1 \
\ls12\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 GENERIC: bad time/space complexity\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Typical process\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls13\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Almost every candidate will quickly realize we need to do book keeping and store information about last/next execution time\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 From there, we have 2 paths: people think about sliding window [leading to solution with queue] or about mapping task types to information about them [hash tables]\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If candidate figures out that we need to do book keeping, but cannot decide what form of it [yes happens], ask a question [this is not a real hint, but something to steer candidate's thoughts back to the original problem]: imagine you have this book keeping data structure, how would you solve the problem\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 I have not seen much confusion in this question, so next usually candidate comes up with looping over input and counting time slots\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Observe if candidate notices that looking backward over input sequence is not sufficient\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Observe if candidate is clear about indexing: from 0 or from 1, storing slot of execution for current task, or next empty (and so on)\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Candidates often struggle with the exact condition/jump equation. Often because it requires accuracy under stress. Have a tiny example ready as hint --
\f0\b \'a0input 1, 1, cooldown: 2, output: 1 _ _ 1\'a0
\f1\b0 (but as usual, give candidate chance to reason on their own before hinting)\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If they come up with solution that does not jump, but iterates over empty slots observe if they notice it when describing runtime\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If they iterate over empty slots ask if we can do it faster [if candidate does not progress, you can hint, by asking if we can optimize the example of\'a0
\f0\b input 1, 1, 1, cooldown = 5
\f1\b0 ]\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For candidates solving the problem using queue ask what generates the cost [lookup in the queue] and ask if it is possible to speed up this part\cb1 \
\ls13\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For candidates solving the problem using hash map, ask about memory used and if we can optimize it. When candidate has no idea after some time, you can simplify: imagine cooldown < 10. In such case what can we do [in each iteration go through the hash map and delete old entries, complexity is
\f0\b \'a0O(10*N)
\f1\b0 \'a0which is the same as\'a0
\f0\b O(N)
\f1\b0 ]. Now ask why that would not work in general (because cooldown is no longer constant factor). Candidate will either figure out that we can use queue to delete old entries (very good) or not. Not figuring that out is still ok, time for you to hint: this is so costly because we try to clean up the hash map on every iteration, what if we cleaned it up only from time to time.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Sample Solution\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Here is a basic implementation of solution (A) in python. This keeps a map tracking the last time each task was executed, to figure out if cooldown slots need to be inserted.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf9 \cb7 \strokec9 def\cf6 \strokec6  \cf10 \strokec10 compute_runtime\cf6 \strokec6 (tasks_in, cooldown):\
    last_executed = \{\}\
    position = \cf8 \strokec8 0\cf6 \strokec6 \
    \cf9 \strokec9 for\cf6 \strokec6  task \cf9 \strokec9 in\cf6 \strokec6  tasks_in:\
        since_last = position - last_executed.get(task, -cooldown)\
        wait = max(\cf8 \strokec8 0\cf6 \strokec6 , cooldown - since_last)\
        position += \cf8 \strokec8 1\cf6 \strokec6  + wait\
        last_executed[task] = position\
    \cf9 \strokec9 return\cf6 \strokec6  position\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 Now the same with better memory complexity (and same time complexity)\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf9 \cb7 \strokec9 def\cf6 \strokec6  \cf10 \strokec10 compute_runtime\cf6 \strokec6 (tasks_in, cooldown):\
    last_executed = \{\}\
    position = \cf8 \strokec8 0\cf6 \strokec6 \
    \cf9 \strokec9 for\cf6 \strokec6  i, task \cf9 \strokec9 in\cf6 \strokec6  enumarate(tasks_in):\
        since_last = position - last_executed.get(task, -cooldown)\
        wait = max(\cf8 \strokec8 0\cf6 \strokec6 , cooldown - since_last)\
        position += \cf8 \strokec8 1\cf6 \strokec6  + wait\
        last_executed[task] = position\
        \cf9 \strokec9 if\cf6 \strokec6  i % cooldown == \cf8 \strokec8 0\cf6 \strokec6 :\
          to_remove = []\
          \cf9 \strokec9 for\cf6 \strokec6  task, etime \cf9 \strokec9 in\cf6 \strokec6  last_executed.iteritems():\
            \cf9 \strokec9 if\cf6 \strokec6  cooldown < (position - etime):\
              to_remove.append(task)\
          \cf9 \strokec9 for\cf6 \strokec6  task \cf9 \strokec9 in\cf6 \strokec6  to_remove:\
            \cf9 \strokec9 del\cf6 \strokec6  last_executed[task] \
    \cf9 \strokec9 return\cf6 \strokec6  position\
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 \strokec2 Common Mistakes\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 The most common mistake I see is candidates getting confused between indices into the input array and indices into the output array.\cb1 \
\cb3 While candidates don't actually need to build the output array, checking if a task can be executed yet requires comparing distances since the last element of the same type in the output array. Candidates often end up incorrectly checking the distance in the input array rather than the distance in the output array.\cb1 \
\pard\pardeftab720\sl480\sa150\partightenfactor0
\cf11 \cb11 \strokec11 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 \strokec2 Follow-up Question\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Write a function that takes as input a list of tasks to run, and the recovery interval, and returns an optimal ordering to run the tasks.\cb1 \
\cb3 This question is much harder, and can generally take up the full interview time by itself. If candidates solve the first question very easily I'll move on to this one. If candidate fully and correctly solves this question: hire immediately. Other thing to note about this question: the optimal solution is greedy (it is very hard to prove [in mathematical sense] it is correct, but it 'feels' correct). I dislike that, because chances are candidate also feels [as opposed to knowing] it is correct.\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Examples\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\fs36 \cf2 \cb3 Example 1\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 \
Recovery interval: \cf8 \strokec8 2\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 We have 3 tasks of type A to perform, and we have to wait 2 time slots to recover between each task of the same type.\cb1 \
\cb3 The optimal output in this case is "1__1__1". All of the tasks are of the same type, and we have to wait 2 slots between each one.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Example 2\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 \
Recovery interval: \cf8 \strokec8 2\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 An optimal ordering is "1 2 3 1 2 3 1 2 3". Note that there are other optimal orderings, such as "3 2 1 3 2 1 3 2 1". Any optimal ordering is a valid answer.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Example 3\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 , \cf8 \strokec8 4\cf6 \strokec6 \
Recovery interval: \cf8 \strokec8 1\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 An optimal ordering is "4 1 4 2 4 3 4"\cb1 \
\cb3 Note that in this case there are more 4 tasks, so an optimal ordering must execute the 4 tasks as soon as possible.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Example 4\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2\b0\fs30 \cf6 \cb7 \strokec6 Tasks: \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 3\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 2\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6 , \cf8 \strokec8 1\cf6 \strokec6  \
Recovery interval: \cf8 \strokec8 1\cf6 \strokec6 \
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb3 \strokec2 An optimal ordering is "3 2 3 2 3 1 3 2 1 3 2 1"\cb1 \
\cb3 Note this case breaks the solution that tries to first place most common task at every cooldown slot, then second most popular and so on (it would produce: "3 2 3 2 3 2 3 2 3 1 _ 1 _ 1")\cb1 \
\pard\pardeftab720\sl480\sa200\partightenfactor0

\f0\b\fs42 \cf2 \cb3 Solution\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 To correctly handle cases like example 3, more numerous tasks must be chosen first. To generate an optimal ordering, you can simply pick the task with the highest count, as long as it is valid to be executed (isn't waiting on the recovery period).\cb1 \
\cb3 One of the more efficient ways to do this is using a heap. Valid tasks to run are stored on the heap, ordered by count. When a task is selected, you remove it from the heap and only add it back once the recovery interval has passed.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 Notes\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls14\ilvl0
\f1\b0\fs30 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Make sure the candidate's solution handles Example 3 correctly. Many candidates don't notice that they need to execute the most frequent tasks first.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl480\partightenfactor0
\ls15\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 I don't expect candidates to implement a heap or other common data structures -- I'll let them make up their own heap API to use in whatever language they prefer.\cb1 \
\pard\pardeftab720\sl480\sa100\partightenfactor0

\f0\b\fs36 \cf2 \cb3 C++ Implementation\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f1\b0\fs30 \cf2 \cb3 Here is a full solution in C++. It's unfortunately slightly complicated by the fact that C++'s standard heap implementation is slightly awkward to use.\cb1 \
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf9 \cb7 \strokec9 typedef\cf6 \strokec6  \cf9 \strokec9 int\cf6 \strokec6  Task;\
\cf9 \strokec9 const\cf6 \strokec6  Task kDummyTask = \cf12 \strokec12 '_'\cf6 \strokec6 ;\
\cf9 \strokec9 struct\cf6 \strokec6  TaskCount \{\
  TaskCount() : task(kDummyTask), count(\cf8 \strokec8 0\cf6 \strokec6 ) \{\}\
  TaskCount(Task t, \cf9 \strokec9 size_t\cf6 \strokec6  c) : task(t), count(c) \{\}\
\
  Task task;\
  \cf9 \strokec9 size_t\cf6 \strokec6  count;\
\};\
\cf9 \strokec9 bool\cf6 \strokec6  \cf10 \strokec10 taskCountCmp\cf6 \strokec6 (\cf9 \strokec9 const\cf6 \strokec6  TaskCount& t1, \cf9 \strokec9 const\cf6 \strokec6  TaskCount& t2) \{\
  \cf9 \strokec9 if\cf6 \strokec6  (t1.count == t2.count) \{\
    \cf9 \strokec9 return\cf6 \strokec6  t1.task > t2.task;  
\f3\i \cf13 \strokec13 // not necessary, just for nicer sorted output
\f2\i0 \cf6 \strokec6 \
  \}\
  \cf9 \strokec9 return\cf6 \strokec6  t1.count < t2.count;\
\}\
\
\pard\pardeftab720\sl480\partightenfactor0
\cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <Task> scheduleTasks(\cf9 \strokec9 const\cf6 \strokec6  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <Task>& tasks,\
                                \cf9 \strokec9 unsigned\cf6 \strokec6  \cf9 \strokec9 int\cf6 \strokec6  interval) \{\
  
\f3\i \cf13 \strokec13 // Count how many times each task appears
\f2\i0 \cf6 \strokec6 \
  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 map\cf6 \strokec6 <Task, \cf9 \strokec9 size_t\cf6 \strokec6 > counts;\
  \cf9 \strokec9 for\cf6 \strokec6  (\cf9 \strokec9 const\cf6 \strokec6  \cf9 \strokec9 auto\cf6 \strokec6 & task : tasks) \{\
    counts[task] += \cf8 \strokec8 1\cf6 \strokec6 ;\
  \}\
  
\f3\i \cf13 \strokec13 // Build a max-heap from the results, ordered by count
\f2\i0 \cf6 \strokec6 \
  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <TaskCount> heap;\
  \cf9 \strokec9 for\cf6 \strokec6  (\cf9 \strokec9 const\cf6 \strokec6  \cf9 \strokec9 auto\cf6 \strokec6 & entry : counts) \{\
    heap.emplace_back(entry.first, entry.second);\
  \}\
  \cf14 \strokec14 std\cf6 \strokec6 ::make_heap(heap.begin(), heap.end(), taskCountCmp);\
\
  
\f3\i \cf13 \strokec13 // Now build up the output, starting with the most frequent tasks first
\f2\i0 \cf6 \strokec6 \
  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <Task> out;\
  
\f3\i \cf13 \strokec13 // A circular buffer of tasks waiting on their recovery interval to expire.
\f2\i0 \cf6 \strokec6 \
  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <TaskCount> recovery;\
  recovery.resize(interval + \cf8 \strokec8 1\cf6 \strokec6 );\
  \cf9 \strokec9 unsigned\cf6 \strokec6  \cf9 \strokec9 int\cf6 \strokec6  recoveryIdx = \cf8 \strokec8 0\cf6 \strokec6 ;\
  \cf9 \strokec9 size_t\cf6 \strokec6  tasksRun = \cf8 \strokec8 0\cf6 \strokec6 ;\
  \cf9 \strokec9 while\cf6 \strokec6  (tasksRun < tasks.size()) \{\
    
\f3\i \cf13 \strokec13 // The item at recovery[recoveryIdx] is ready to run again,
\f2\i0 \cf6 \strokec6 \
    
\f3\i \cf13 \strokec13 // and can go back into the heap.
\f2\i0 \cf6 \strokec6 \
    \cf9 \strokec9 if\cf6 \strokec6  (recovery[recoveryIdx].count > \cf8 \strokec8 0\cf6 \strokec6 ) \{\
      heap.push_back(recovery[recoveryIdx]);\
      \cf14 \strokec14 std\cf6 \strokec6 ::push_heap(heap.begin(), heap.end(), taskCountCmp);\
    \}\
\
    
\f3\i \cf13 \strokec13 // Get the next item to run.
\f2\i0 \cf6 \strokec6 \
    
\f3\i \cf13 \strokec13 // Note that if the heap is empty at this point, all tasks are waiting on
\f2\i0 \cf6 \strokec6 \
    
\f3\i \cf13 \strokec13 // the recovery period and we have to run a dummy task instead.
\f2\i0 \cf6 \strokec6 \
    TaskCount tc;\
    \cf9 \strokec9 if\cf6 \strokec6  (!heap.empty()) \{\
      \cf14 \strokec14 std\cf6 \strokec6 ::pop_heap(heap.begin(), heap.end(), taskCountCmp);\
      tc = heap.back();\
      heap.pop_back();\
      assert(tc.count > \cf8 \strokec8 0\cf6 \strokec6 );\
      --tc.count;\
      ++tasksRun;\
    \}\
    out.push_back(tc.task);\
    recovery[recoveryIdx] = tc;\
    ++recoveryIdx;\
    \cf9 \strokec9 if\cf6 \strokec6  (recoveryIdx > interval) \{\
      recoveryIdx = \cf8 \strokec8 0\cf6 \strokec6 ;\
    \}\
  \}\
\
  \cf9 \strokec9 return\cf6 \strokec6  out;\
\}\
\pard\pardeftab720\sl480\partightenfactor0

\f1 \cf2 \cb1 \strokec2 \
\cb3 Note: If you ask the question to return the minimum number of time slots instead of the actual ordering, it is solvable in O(n) time, O(num_task_types) space, but I've never had any candidate figure it out.\
\pard\pardeftab720\sl480\partightenfactor0

\f2 \cf9 \cb7 \strokec9 size_t\cf6 \strokec6  computeRuntime(\cf9 \strokec9 const\cf6 \strokec6  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 vector\cf6 \strokec6 <\cf9 \strokec9 int\cf6 \strokec6 >& tasks, \cf9 \strokec9 const\cf6 \strokec6  \cf9 \strokec9 size_t\cf6 \strokec6  cooldown) \{\
  \cf14 \strokec14 std\cf6 \strokec6 ::\cf14 \strokec14 unordered_map\cf6 \strokec6 <\cf9 \strokec9 int\cf6 \strokec6 , \cf9 \strokec9 size_t\cf6 \strokec6 > \cf14 \strokec14 map\cf6 \strokec6 ;\
  \cf9 \strokec9 for\cf6 \strokec6  (\cf9 \strokec9 const\cf6 \strokec6  \cf9 \strokec9 auto\cf6 \strokec6 & task : tasks) \{\
    \cf14 \strokec14 map\cf6 \strokec6 [task]++;\
  \}\
  \cf9 \strokec9 size_t\cf6 \strokec6  maxFreq = \cf8 \strokec8 0\cf6 \strokec6 ;\
  \cf9 \strokec9 size_t\cf6 \strokec6  numMaxFreq = \cf8 \strokec8 0\cf6 \strokec6 ;\
  \cf9 \strokec9 for\cf6 \strokec6  (\cf9 \strokec9 const\cf6 \strokec6  \cf9 \strokec9 auto\cf6 \strokec6 & pair : \cf14 \strokec14 map\cf6 \strokec6 ) \{\
    \cf9 \strokec9 if\cf6 \strokec6  (pair.second > maxFreq) \{\
      maxFreq = pair.second;\
      numMaxFreq = \cf8 \strokec8 1\cf6 \strokec6 ;\
    \} \cf9 \strokec9 else\cf6 \strokec6  \cf9 \strokec9 if\cf6 \strokec6  (pair.second == maxFreq) \{\
      numMaxFreq++;\
    \}\
  \}\
  \cf9 \strokec9 return\cf6 \strokec6  \cf14 \strokec14 std\cf6 \strokec6 ::max(tasks.size(), (maxFreq - \cf8 \strokec8 1\cf6 \strokec6 )(cooldown + \cf8 \strokec8 1\cf6 \strokec6 ) + numMaxFreq);\
\}\
}